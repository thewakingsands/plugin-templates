/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};

;// CONCATENATED MODULE: ./resources/not_reached.ts
// Helper Error for TypeScript situations where the programmer thinks they
// know better than TypeScript that some situation will never occur.

// The intention here is that the programmer does not expect a particular
// bit of code to happen, and so has not written careful error handling.
// If it does occur, at least there will be an error and we can figure out why.
// This is preferable to casting or disabling TypeScript altogether in order to
// avoid syntax errors.

// One common example is a regex, where if the regex matches then all of the
// (non-optional) regex groups will also be valid, but TypeScript doesn't know.
class not_reached_UnreachableCode extends Error {
  constructor() {
    super('This code shouldn\'t be reached');
  }
}
;// CONCATENATED MODULE: ./resources/languages.ts
const languages = ['en', 'de', 'fr', 'ja', 'cn', 'ko'];
const langMap = {
  en: {
    en: 'English',
    de: 'German',
    fr: 'French',
    ja: 'Japanese',
    cn: 'Chinese',
    ko: 'Korean'
  },
  de: {
    en: 'Englisch',
    de: 'Deutsch',
    fr: 'Französisch',
    ja: 'Japanisch',
    cn: 'Chinesisch',
    ko: 'Koreanisch'
  },
  fr: {
    en: 'Anglais',
    de: 'Allemand',
    fr: 'Français',
    ja: 'Japonais',
    cn: 'Chinois',
    ko: 'Coréen'
  },
  ja: {
    en: '英語',
    de: 'ドイツ語',
    fr: 'フランス語',
    ja: '日本語',
    cn: '中国語',
    ko: '韓国語'
  },
  cn: {
    en: '英文',
    de: '德文',
    fr: '法文',
    ja: '日文',
    cn: '中文',
    ko: '韩文'
  },
  ko: {
    en: '영어',
    de: '독일어',
    fr: '프랑스어',
    ja: '일본어',
    cn: '중국어',
    ko: '한국어'
  }
};
const isLang = lang => {
  const langStrs = languages;
  if (lang === undefined) return false;
  return langStrs.includes(lang);
};
const langToLocale = lang => {
  return {
    en: 'en',
    de: 'de',
    fr: 'fr',
    ja: 'ja',
    cn: 'zh-CN',
    ko: 'ko'
  }[lang];
};
const browserLanguagesToLang = languages => {
  const lang = [...navigator.languages, 'en'].map(l => l.slice(0, 2))
  // Remap `zh` to `cn` to match cactbot languages
  .map(l => l === 'zh' ? 'cn' : l).filter(l => languages.includes(l))[0];
  return isLang(lang) ? lang : 'en';
};
;// CONCATENATED MODULE: ./resources/pet_names.ts
// Auto-generated from gen_pet_names.ts
// DO NOT EDIT THIS FILE DIRECTLY

const data = {
  'cn': ['绿宝石兽', '黄宝石兽', '朝日小仙女', '夕月小仙女', '车式浮空炮塔', '象式浮空炮塔', '亚灵神巴哈姆特', '亚灵神不死鸟', '炽天使', '月长宝石兽', '英雄的掠影', '后式自走人偶', '分身', '宝石兽', '红宝石兽', '伊弗利特之灵', '泰坦之灵', '迦楼罗之灵', '红宝石伊弗利特', '黄宝石泰坦', '绿宝石迦楼罗', '琥珀宝石兽', '黑曜宝石兽'],
  'de': ['Smaragd-Karfunkel', 'Topas-Karfunkel', 'Eos', 'Selene', 'Selbstschuss-Gyrocopter TURM', 'Selbstschuss-Gyrocopter LÄUFER', 'Demi-Bahamut', 'Demi-Phönix', 'Seraph', 'Mondstein-Karfunkel', 'Schattenschemen', 'Automaton DAME', 'Gedoppeltes Ich', 'Karfunkel', 'Rubin-Karfunkel', 'Ifrit-Egi', 'Titan-Egi', 'Garuda-Egi', 'Rubin-Ifrit', 'Topas-Titan', 'Smaragd-Garuda', 'Bernstein-Karfunkel', 'Obsidian-Karfunkel'],
  'en': ['Emerald Carbuncle', 'Topaz Carbuncle', 'Eos', 'Selene', 'Rook Autoturret', 'Bishop Autoturret', 'Demi-Bahamut', 'Demi-Phoenix', 'Seraph', 'Moonstone Carbuncle', 'Esteem', 'Automaton Queen', 'Bunshin', 'Carbuncle', 'Ruby Carbuncle', 'Ifrit-Egi', 'Titan-Egi', 'Garuda-Egi', 'Ruby Ifrit', 'Topaz Titan', 'Emerald Garuda', 'Amber Carbuncle', 'Obsidian Carbuncle'],
  'fr': ['Carbuncle émeraude', 'Carbuncle topaze', 'Eos', 'Selene', 'Auto-tourelle Tour', 'Auto-tourelle Fou', 'Demi-Bahamut', 'Demi-Phénix', 'Séraphin', 'Carbuncle hécatolite', 'Estime', 'Automate Reine', 'Ombre', 'Carbuncle', 'Carbuncle rubis', 'Ifrit-Egi', 'Titan-Egi', 'Garuda-Egi', 'Ifrit rubis', 'Titan topaze', 'Garuda émeraude', 'Carbuncle ambre', 'Carbuncle obsidienne'],
  'ja': ['カーバンクル・エメラルド', 'カーバンクル・トパーズ', 'フェアリー・エオス', 'フェアリー・セレネ', 'オートタレット・ルーク', 'オートタレット・ビショップ', 'デミ・バハムート', 'デミ・フェニックス', 'セラフィム', 'カーバンクル・ムーンストーン', '英雄の影身', 'オートマトン・クイーン', '分身', 'カーバンクル', 'カーバンクル・ルビー', 'イフリート・エギ', 'タイタン・エギ', 'ガルーダ・エギ', 'イフリート・ルビー', 'タイタン・トパーズ', 'ガルーダ・エメラルド', 'カーバンクル・アンバー', 'カーバンクル・オブシダン'],
  'ko': ['카벙클 에메랄드', '카벙클 토파즈', '요정 에오스', '요정 셀레네', '자동포탑 룩', '자동포탑 비숍', '데미바하무트', '데미피닉스', '세라핌', '카벙클 문스톤', '영웅의 환영', '자동인형 퀸', '분신', '카벙클', '카벙클 루비', '이프리트 에기', '타이탄 에기', '가루다 에기', '이프리트 루비', '타이탄 토파즈', '가루다 에메랄드', '카벙클 앰버', '카벙클 옵시디언']
};
/* harmony default export */ const pet_names = (data);
;// CONCATENATED MODULE: ./resources/netlog_defs.ts
// TODO: Maybe bring in a helper library that can compile-time extract these keys instead?
const combatantMemoryKeys = ['CurrentWorldID', 'WorldID', 'WorldName', 'BNpcID', 'BNpcNameID', 'PartyType', 'ID', 'OwnerID', 'WeaponId', 'Type', 'Job', 'Level', 'Name', 'CurrentHP', 'MaxHP', 'CurrentMP', 'MaxMP', 'PosX', 'PosY', 'PosZ', 'Heading', 'MonsterType', 'Status', 'ModelStatus', 'AggressionStatus', 'TargetID', 'IsTargetable', 'Radius', 'Distance', 'EffectiveDistance', 'NPCTargetID', 'CurrentGP', 'MaxGP', 'CurrentCP', 'MaxCP', 'PCTargetID', 'IsCasting1', 'IsCasting2', 'CastBuffID', 'CastTargetID', 'CastDurationCurrent', 'CastDurationMax', 'TransformationId'];
const latestLogDefinitions = {
  GameLog: {
    type: '00',
    name: 'GameLog',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'ChatLog',
    fields: {
      type: 0,
      timestamp: 1,
      code: 2,
      name: 3,
      line: 4
    },
    subFields: {
      code: {
        '0039': {
          name: 'message',
          canAnonymize: true
        },
        '0038': {
          name: 'echo',
          canAnonymize: true
        },
        '0044': {
          name: 'dialog',
          canAnonymize: true
        },
        '0839': {
          name: 'message',
          canAnonymize: true
        }
      }
    },
    firstOptionalField: undefined
  },
  ChangeZone: {
    type: '01',
    name: 'ChangeZone',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'Territory',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      name: 3
    },
    lastInclude: true,
    canAnonymize: true,
    firstOptionalField: undefined
  },
  ChangedPlayer: {
    type: '02',
    name: 'ChangedPlayer',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'ChangePrimaryPlayer',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      name: 3
    },
    playerIds: {
      2: 3
    },
    lastInclude: true,
    canAnonymize: true,
    firstOptionalField: undefined
  },
  AddedCombatant: {
    type: '03',
    name: 'AddedCombatant',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'AddCombatant',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      name: 3,
      job: 4,
      level: 5,
      ownerId: 6,
      worldId: 7,
      world: 8,
      npcNameId: 9,
      npcBaseId: 10,
      currentHp: 11,
      hp: 12,
      currentMp: 13,
      mp: 14,
      // maxTp: 15,
      // tp: 16,
      x: 17,
      y: 18,
      z: 19,
      heading: 20
    },
    playerIds: {
      2: 3,
      6: null
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  RemovedCombatant: {
    type: '04',
    name: 'RemovedCombatant',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'RemoveCombatant',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      name: 3,
      job: 4,
      level: 5,
      owner: 6,
      world: 8,
      npcNameId: 9,
      npcBaseId: 10,
      hp: 12,
      x: 17,
      y: 18,
      z: 19,
      heading: 20
    },
    playerIds: {
      2: 3,
      6: null
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  PartyList: {
    type: '11',
    name: 'PartyList',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'PartyList',
    fields: {
      type: 0,
      timestamp: 1,
      partyCount: 2,
      id0: 3,
      id1: 4,
      id2: 5,
      id3: 6,
      id4: 7,
      id5: 8,
      id6: 9,
      id7: 10,
      id8: 11,
      id9: 12,
      id10: 13,
      id11: 14,
      id12: 15,
      id13: 16,
      id14: 17,
      id15: 18,
      id16: 19,
      id17: 20,
      id18: 21,
      id19: 22,
      id20: 23,
      id21: 24,
      id22: 25,
      id23: 26
    },
    playerIds: {
      3: null,
      4: null,
      5: null,
      6: null,
      7: null,
      8: null,
      9: null,
      10: null,
      11: null,
      12: null,
      13: null,
      14: null,
      15: null,
      16: null,
      17: null,
      18: null,
      19: null,
      20: null,
      21: null,
      22: null,
      23: null,
      24: null,
      25: null,
      26: null
    },
    firstOptionalField: 3,
    canAnonymize: true,
    lastInclude: true
  },
  PlayerStats: {
    type: '12',
    name: 'PlayerStats',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'PlayerStats',
    fields: {
      type: 0,
      timestamp: 1,
      job: 2,
      strength: 3,
      dexterity: 4,
      vitality: 5,
      intelligence: 6,
      mind: 7,
      piety: 8,
      attackPower: 9,
      directHit: 10,
      criticalHit: 11,
      attackMagicPotency: 12,
      healMagicPotency: 13,
      determination: 14,
      skillSpeed: 15,
      spellSpeed: 16,
      tenacity: 18,
      localContentId: 19
    },
    canAnonymize: true,
    lastInclude: true,
    firstOptionalField: undefined
  },
  StartsUsing: {
    type: '20',
    name: 'StartsUsing',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'StartsCasting',
    fields: {
      type: 0,
      timestamp: 1,
      sourceId: 2,
      source: 3,
      id: 4,
      ability: 5,
      targetId: 6,
      target: 7,
      castTime: 8,
      x: 9,
      y: 10,
      z: 11,
      heading: 12
    },
    possibleRsvFields: [5],
    blankFields: [6],
    playerIds: {
      2: 3,
      6: 7
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  Ability: {
    type: '21',
    name: 'Ability',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'ActionEffect',
    fields: {
      type: 0,
      timestamp: 1,
      sourceId: 2,
      source: 3,
      id: 4,
      ability: 5,
      targetId: 6,
      target: 7,
      flags: 8,
      damage: 9,
      targetCurrentHp: 24,
      targetMaxHp: 25,
      targetCurrentMp: 26,
      targetMaxMp: 27,
      // targetCurrentTp: 28,
      // targetMaxTp: 29,
      targetX: 30,
      targetY: 31,
      targetZ: 32,
      targetHeading: 33,
      currentHp: 34,
      maxHp: 35,
      currentMp: 36,
      maxMp: 37,
      // currentTp: 38;
      // maxTp: 39;
      x: 40,
      y: 41,
      z: 42,
      heading: 43,
      sequence: 44,
      targetIndex: 45,
      targetCount: 46
    },
    possibleRsvFields: [5],
    playerIds: {
      2: 3,
      6: 7
    },
    blankFields: [6],
    canAnonymize: true,
    firstOptionalField: undefined
  },
  NetworkAOEAbility: {
    type: '22',
    name: 'NetworkAOEAbility',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'AOEActionEffect',
    fields: {
      type: 0,
      timestamp: 1,
      sourceId: 2,
      source: 3,
      id: 4,
      ability: 5,
      targetId: 6,
      target: 7,
      flags: 8,
      damage: 9,
      targetCurrentHp: 24,
      targetMaxHp: 25,
      targetCurrentMp: 26,
      targetMaxMp: 27,
      // targetCurrentTp: 28,
      // targetMaxTp: 29,
      targetX: 30,
      targetY: 31,
      targetZ: 32,
      targetHeading: 33,
      currentHp: 34,
      maxHp: 35,
      currentMp: 36,
      maxMp: 37,
      // currentTp: 38;
      // maxTp: 39;
      x: 40,
      y: 41,
      z: 42,
      heading: 43,
      sequence: 44,
      targetIndex: 45,
      targetCount: 46
    },
    possibleRsvFields: [5],
    playerIds: {
      2: 3,
      6: 7
    },
    blankFields: [6],
    canAnonymize: true,
    firstOptionalField: undefined
  },
  NetworkCancelAbility: {
    type: '23',
    name: 'NetworkCancelAbility',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'CancelAction',
    fields: {
      type: 0,
      timestamp: 1,
      sourceId: 2,
      source: 3,
      id: 4,
      name: 5,
      reason: 6
    },
    possibleRsvFields: [5],
    playerIds: {
      2: 3
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  NetworkDoT: {
    type: '24',
    name: 'NetworkDoT',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'DoTHoT',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      name: 3,
      which: 4,
      effectId: 5,
      damage: 6,
      currentHp: 7,
      maxHp: 8,
      currentMp: 9,
      maxMp: 10,
      // currentTp: 11,
      // maxTp: 12,
      x: 13,
      y: 14,
      z: 15,
      heading: 16,
      sourceId: 17,
      source: 18,
      // An id number lookup into the AttackType table
      damageType: 19,
      sourceCurrentHp: 20,
      sourceMaxHp: 21,
      sourceCurrentMp: 22,
      sourceMaxMp: 23,
      // sourceCurrentTp: 24,
      // sourceMaxTp: 25,
      sourceX: 26,
      sourceY: 27,
      sourceZ: 28,
      sourceHeading: 29
    },
    playerIds: {
      2: 3,
      17: 18
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  WasDefeated: {
    type: '25',
    name: 'WasDefeated',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'Death',
    fields: {
      type: 0,
      timestamp: 1,
      targetId: 2,
      target: 3,
      sourceId: 4,
      source: 5
    },
    playerIds: {
      2: 3,
      4: 5
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  GainsEffect: {
    type: '26',
    name: 'GainsEffect',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'StatusAdd',
    fields: {
      type: 0,
      timestamp: 1,
      effectId: 2,
      effect: 3,
      duration: 4,
      sourceId: 5,
      source: 6,
      targetId: 7,
      target: 8,
      count: 9,
      targetMaxHp: 10,
      sourceMaxHp: 11
    },
    possibleRsvFields: [3],
    playerIds: {
      5: 6,
      7: 8
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  HeadMarker: {
    type: '27',
    name: 'HeadMarker',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'TargetIcon',
    fields: {
      type: 0,
      timestamp: 1,
      targetId: 2,
      target: 3,
      id: 6
    },
    playerIds: {
      2: 3
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  NetworkRaidMarker: {
    type: '28',
    name: 'NetworkRaidMarker',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'WaymarkMarker',
    fields: {
      type: 0,
      timestamp: 1,
      operation: 2,
      waymark: 3,
      id: 4,
      name: 5,
      x: 6,
      y: 7,
      z: 8
    },
    playerIds: {
      4: 5
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  NetworkTargetMarker: {
    type: '29',
    name: 'NetworkTargetMarker',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'SignMarker',
    fields: {
      type: 0,
      timestamp: 1,
      operation: 2,
      // Add, Update, Delete
      waymark: 3,
      id: 4,
      name: 5,
      targetId: 6,
      targetName: 7
    },
    playerIds: {
      4: 5,
      6: 7
    },
    firstOptionalField: undefined
  },
  LosesEffect: {
    type: '30',
    name: 'LosesEffect',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'StatusRemove',
    fields: {
      type: 0,
      timestamp: 1,
      effectId: 2,
      effect: 3,
      sourceId: 5,
      source: 6,
      targetId: 7,
      target: 8,
      count: 9
    },
    possibleRsvFields: [3],
    playerIds: {
      5: 6,
      7: 8
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  NetworkGauge: {
    type: '31',
    name: 'NetworkGauge',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'Gauge',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      data0: 3,
      data1: 4,
      data2: 5,
      data3: 6
    },
    playerIds: {
      2: null
    },
    // Sometimes this last field looks like a player id.
    // For safety, anonymize all of the gauge data.
    firstUnknownField: 3,
    canAnonymize: true,
    firstOptionalField: undefined
  },
  NetworkWorld: {
    type: '32',
    name: 'NetworkWorld',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'World',
    fields: {
      type: 0,
      timestamp: 1
    },
    isUnknown: true,
    firstOptionalField: undefined
  },
  ActorControl: {
    type: '33',
    name: 'ActorControl',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'Director',
    fields: {
      type: 0,
      timestamp: 1,
      instance: 2,
      command: 3,
      data0: 4,
      data1: 5,
      data2: 6,
      data3: 7
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  NameToggle: {
    type: '34',
    name: 'NameToggle',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'NameToggle',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      name: 3,
      targetId: 4,
      targetName: 5,
      toggle: 6
    },
    playerIds: {
      2: 3,
      4: 5
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  Tether: {
    type: '35',
    name: 'Tether',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'Tether',
    fields: {
      type: 0,
      timestamp: 1,
      sourceId: 2,
      source: 3,
      targetId: 4,
      target: 5,
      id: 8
    },
    playerIds: {
      2: 3,
      4: 5
    },
    canAnonymize: true,
    firstUnknownField: 9,
    firstOptionalField: undefined
  },
  LimitBreak: {
    type: '36',
    name: 'LimitBreak',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'LimitBreak',
    fields: {
      type: 0,
      timestamp: 1,
      valueHex: 2,
      bars: 3
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  NetworkEffectResult: {
    type: '37',
    name: 'NetworkEffectResult',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'EffectResult',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      name: 3,
      sequenceId: 4,
      currentHp: 5,
      maxHp: 6,
      currentMp: 7,
      maxMp: 8,
      currentShield: 9,
      // Field index 10 is always `0`
      x: 11,
      y: 12,
      z: 13,
      heading: 14
    },
    playerIds: {
      2: 3
    },
    firstUnknownField: 22,
    canAnonymize: true,
    firstOptionalField: undefined
  },
  StatusEffect: {
    type: '38',
    name: 'StatusEffect',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'StatusList',
    fields: {
      type: 0,
      timestamp: 1,
      targetId: 2,
      target: 3,
      jobLevelData: 4,
      hp: 5,
      maxHp: 6,
      mp: 7,
      maxMp: 8,
      currentShield: 9,
      // Field index 10 is always `0`
      x: 11,
      y: 12,
      z: 13,
      heading: 14,
      data0: 15,
      data1: 16,
      data2: 17,
      data3: 18,
      data4: 19,
      data5: 20
      // Variable number of triplets here, but at least one.
    },

    playerIds: {
      2: 3
    },
    firstUnknownField: 18,
    canAnonymize: true,
    firstOptionalField: 18
  },
  NetworkUpdateHP: {
    type: '39',
    name: 'NetworkUpdateHP',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'UpdateHp',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      name: 3,
      currentHp: 4,
      maxHp: 5,
      currentMp: 6,
      maxMp: 7,
      // currentTp: 8,
      // maxTp: 9,
      x: 10,
      y: 11,
      z: 12,
      heading: 13
    },
    playerIds: {
      2: 3
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  Map: {
    type: '40',
    name: 'Map',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'ChangeMap',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      regionName: 3,
      placeName: 4,
      placeNameSub: 5
    },
    canAnonymize: true,
    firstOptionalField: undefined,
    lastInclude: true
  },
  SystemLogMessage: {
    type: '41',
    name: 'SystemLogMessage',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'SystemLogMessage',
    fields: {
      type: 0,
      timestamp: 1,
      instance: 2,
      id: 3,
      param0: 4,
      param1: 5,
      param2: 6
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  StatusList3: {
    type: '42',
    name: 'StatusList3',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'StatusList3',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      name: 3
      // triplets of fields from here (effectId, data, playerId)?
    },

    playerIds: {
      2: 3
    },
    canAnonymize: true,
    firstOptionalField: 4,
    firstUnknownField: 4
  },
  ParserInfo: {
    type: '249',
    name: 'ParserInfo',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'Settings',
    fields: {
      type: 0,
      timestamp: 1
    },
    globalInclude: true,
    canAnonymize: true,
    firstOptionalField: undefined
  },
  ProcessInfo: {
    type: '250',
    name: 'ProcessInfo',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'Process',
    fields: {
      type: 0,
      timestamp: 1
    },
    globalInclude: true,
    canAnonymize: true,
    firstOptionalField: undefined
  },
  Debug: {
    type: '251',
    name: 'Debug',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'Debug',
    fields: {
      type: 0,
      timestamp: 1
    },
    globalInclude: true,
    canAnonymize: false,
    firstOptionalField: undefined
  },
  PacketDump: {
    type: '252',
    name: 'PacketDump',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'PacketDump',
    fields: {
      type: 0,
      timestamp: 1
    },
    canAnonymize: false,
    firstOptionalField: undefined
  },
  Version: {
    type: '253',
    name: 'Version',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'Version',
    fields: {
      type: 0,
      timestamp: 1
    },
    globalInclude: true,
    canAnonymize: true,
    firstOptionalField: undefined
  },
  Error: {
    type: '254',
    name: 'Error',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'Error',
    fields: {
      type: 0,
      timestamp: 1
    },
    canAnonymize: false,
    firstOptionalField: undefined
  },
  None: {
    type: '[0-9]+',
    name: 'None',
    source: 'FFXIV_ACT_Plugin',
    messageType: 'None',
    fields: {
      type: 0,
      timestamp: 1
    },
    isUnknown: true,
    firstOptionalField: undefined
  },
  // OverlayPlugin log lines
  LineRegistration: {
    type: '256',
    name: 'LineRegistration',
    source: 'OverlayPlugin',
    messageType: '256',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      source: 3,
      version: 4
    },
    globalInclude: true,
    canAnonymize: true,
    firstOptionalField: undefined
  },
  MapEffect: {
    type: '257',
    name: 'MapEffect',
    source: 'OverlayPlugin',
    messageType: '257',
    fields: {
      type: 0,
      timestamp: 1,
      instance: 2,
      flags: 3,
      // values for the location field seem to vary between instances
      // (e.g. a location of '08' in P5S does not appear to be the same location in P5S as in P6S)
      // but this field does appear to consistently contain position info for the effect rendering
      location: 4,
      data0: 5,
      data1: 6
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  FateDirector: {
    type: '258',
    name: 'FateDirector',
    source: 'OverlayPlugin',
    messageType: '258',
    // fateId and progress are in hex.
    fields: {
      type: 0,
      timestamp: 1,
      category: 2,
      // padding0: 3,
      fateId: 4,
      progress: 5
      // param3: 6,
      // param4: 7,
      // param5: 8,
      // param6: 9,
      // padding1: 10,
    },

    canAnonymize: true,
    firstOptionalField: undefined
  },
  CEDirector: {
    type: '259',
    name: 'CEDirector',
    source: 'OverlayPlugin',
    messageType: '259',
    // all fields are in hex
    fields: {
      type: 0,
      timestamp: 1,
      popTime: 2,
      timeRemaining: 3,
      // unknown0: 4,
      ceKey: 5,
      numPlayers: 6,
      status: 7,
      // unknown1: 8,
      progress: 9
      // unknown2: 10,
      // unknown3: 11,
      // unknown4: 12,
    },

    canAnonymize: true,
    firstOptionalField: undefined
  },
  InCombat: {
    type: '260',
    name: 'InCombat',
    source: 'OverlayPlugin',
    messageType: '260',
    fields: {
      type: 0,
      timestamp: 1,
      inACTCombat: 2,
      inGameCombat: 3,
      isACTChanged: 4,
      isGameChanged: 5
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  CombatantMemory: {
    type: '261',
    name: 'CombatantMemory',
    source: 'OverlayPlugin',
    messageType: '261',
    fields: {
      type: 0,
      timestamp: 1,
      change: 2,
      id: 3
      // from here, pairs of field name/values
    },

    canAnonymize: true,
    firstOptionalField: 5,
    // TODO: fix this data structure and anonymizer to be able to handle repeatingFields.
    // At the very least, Name and PCTargetID need to be anonymized as well.
    firstUnknownField: 4,
    playerIds: {
      3: null
    },
    repeatingFields: {
      startingIndex: 4,
      label: 'pair',
      names: ['key', 'value'],
      sortKeys: true,
      primaryKey: 'key',
      possibleKeys: combatantMemoryKeys
    }
  },
  RSVData: {
    type: '262',
    name: 'RSVData',
    source: 'OverlayPlugin',
    messageType: '262',
    fields: {
      type: 0,
      timestamp: 1,
      locale: 2,
      // unknown0: 3,
      key: 4,
      value: 5
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  StartsUsingExtra: {
    type: '263',
    name: 'StartsUsingExtra',
    source: 'OverlayPlugin',
    messageType: '263',
    fields: {
      type: 0,
      timestamp: 1,
      sourceId: 2,
      id: 3,
      x: 4,
      y: 5,
      z: 6,
      heading: 7
    },
    playerIds: {
      2: null
    },
    canAnonymize: true,
    firstOptionalField: 7
  },
  AbilityExtra: {
    type: '264',
    name: 'AbilityExtra',
    source: 'OverlayPlugin',
    messageType: '264',
    fields: {
      type: 0,
      timestamp: 1,
      sourceId: 2,
      id: 3,
      globalEffectCounter: 4,
      dataFlag: 5,
      x: 6,
      y: 7,
      z: 8,
      heading: 9
    },
    blankFields: [6],
    playerIds: {
      2: null
    },
    canAnonymize: true,
    firstOptionalField: 9
  },
  ContentFinderSettings: {
    type: '265',
    name: 'ContentFinderSettings',
    source: 'OverlayPlugin',
    messageType: '265',
    fields: {
      type: 0,
      timestamp: 1,
      zoneId: 2,
      zoneName: 3,
      inContentFinderContent: 4,
      unrestrictedParty: 5,
      minimalItemLevel: 6,
      silenceEcho: 7,
      explorerMode: 8,
      levelSync: 9
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  NpcYell: {
    type: '266',
    name: 'NpcYell',
    source: 'OverlayPlugin',
    messageType: '266',
    fields: {
      type: 0,
      timestamp: 1,
      npcId: 2,
      npcNameId: 3,
      npcYellId: 4
    },
    canAnonymize: false,
    firstOptionalField: undefined
  },
  BattleTalk2: {
    type: '267',
    name: 'BattleTalk2',
    source: 'OverlayPlugin',
    messageType: '267',
    fields: {
      type: 0,
      timestamp: 1,
      npcId: 2,
      instance: 3,
      npcNameId: 4,
      instanceContentTextId: 5,
      displayMs: 6
      // unknown1: 7,
      // unknown2: 8,
      // unknown3: 9,
      // unknown4: 10,
    },

    canAnonymize: false,
    firstOptionalField: undefined
  },
  Countdown: {
    type: '268',
    name: 'Countdown',
    source: 'OverlayPlugin',
    messageType: '268',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      worldId: 3,
      countdownTime: 4,
      result: 5,
      name: 6
    },
    playerIds: {
      2: 6
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  CountdownCancel: {
    type: '269',
    name: 'CountdownCancel',
    source: 'OverlayPlugin',
    messageType: '269',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      worldId: 3,
      name: 4
    },
    playerIds: {
      2: 4
    },
    canAnonymize: true,
    firstOptionalField: undefined
  },
  ActorMove: {
    type: '270',
    name: 'ActorMove',
    source: 'OverlayPlugin',
    messageType: '270',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      heading: 3,
      // OP calls this 'rotation', but cactbot consistently uses 'heading'
      // unknown1: 4,
      // unknown2: 5,
      x: 6,
      y: 7,
      z: 8
    },
    canAnonymize: false,
    firstOptionalField: undefined
  },
  ActorSetPos: {
    type: '271',
    name: 'ActorSetPos',
    source: 'OverlayPlugin',
    messageType: '271',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      heading: 3,
      // OP call this 'rotation', but cactbot consistently uses 'heading'
      // unknown1: 4,
      // unknown2: 5,
      x: 6,
      y: 7,
      z: 8
    },
    canAnonymize: false,
    firstOptionalField: undefined
  },
  SpawnNpcExtra: {
    type: '272',
    name: 'SpawnNpcExtra',
    source: 'OverlayPlugin',
    messageType: '272',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      parentId: 3,
      tetherId: 4,
      animationState: 5
    },
    canAnonymize: false,
    firstOptionalField: undefined
  },
  ActorControlExtra: {
    type: '273',
    name: 'ActorControlExtra',
    source: 'OverlayPlugin',
    messageType: '273',
    fields: {
      type: 0,
      timestamp: 1,
      id: 2,
      category: 3,
      param1: 4,
      param2: 5,
      param3: 6,
      param4: 7
    },
    canAnonymize: false,
    firstOptionalField: undefined
  }
};
const logDefinitionsVersions = {
  'latest': latestLogDefinitions
};

// Verify that this has the right type, but export `as const`.
const assertLogDefinitions = logDefinitionsVersions;
console.assert(assertLogDefinitions);
/* harmony default export */ const netlog_defs = (logDefinitionsVersions['latest']);
;// CONCATENATED MODULE: ./resources/regexes.ts


const separator = ':';
const matchDefault = '[^:]*';
const matchWithColonsDefault = '(?:[^:]|: )*?';
const fieldsWithPotentialColons = ['effect', 'ability'];
const defaultParams = (type, version, include) => {
  const logType = logDefinitionsVersions[version][type];
  if (include === undefined) {
    include = Object.keys(logType.fields);
    if ('repeatingFields' in logType) {
      include.push(logType.repeatingFields.label);
    }
  }
  const params = {};
  const firstOptionalField = logType.firstOptionalField;
  for (const [prop, index] of Object.entries(logType.fields)) {
    if (!include.includes(prop)) continue;
    const param = {
      field: prop,
      optional: firstOptionalField !== undefined && index >= firstOptionalField
    };
    if (prop === 'type') param.value = logType.type;
    params[index] = param;
  }
  if ('repeatingFields' in logType && include.includes(logType.repeatingFields.label)) {
    params[logType.repeatingFields.startingIndex] = {
      field: logType.repeatingFields.label,
      optional: firstOptionalField !== undefined && logType.repeatingFields.startingIndex >= firstOptionalField,
      repeating: true,
      repeatingKeys: [...logType.repeatingFields.names],
      sortKeys: logType.repeatingFields.sortKeys,
      primaryKey: logType.repeatingFields.primaryKey,
      possibleKeys: [...logType.repeatingFields.possibleKeys]
    };
  }
  return params;
};
const isRepeatingField = (repeating, value) => {
  if (repeating !== true) return false;
  // Allow excluding the field to match for extraction
  if (value === undefined) return true;
  if (!Array.isArray(value)) return false;
  for (const e of value) {
    if (typeof e !== 'object') return false;
  }
  return true;
};
const parseHelper = (params, defKey, fields) => {
  params = params ?? {};
  const validFields = [];
  for (const index in fields) {
    const field = fields[index];
    if (field) validFields.push(field.field);
  }
  regexes_Regexes.validateParams(params, defKey, ['capture', ...validFields]);

  // Find the last key we care about, so we can shorten the regex if needed.
  const capture = regexes_Regexes.trueIfUndefined(params.capture);
  const fieldKeys = Object.keys(fields).sort((a, b) => parseInt(a) - parseInt(b));
  let maxKeyStr;
  if (capture) {
    const keys = [];
    for (const key in fields) keys.push(key);
    let tmpKey = keys.pop();
    if (tmpKey === undefined) {
      maxKeyStr = fieldKeys[fieldKeys.length - 1] ?? '0';
    } else {
      while (fields[tmpKey]?.optional && !((fields[tmpKey]?.field ?? '') in params)) tmpKey = keys.pop();
      maxKeyStr = tmpKey ?? '0';
    }
  } else {
    maxKeyStr = '0';
    for (const key in fields) {
      const value = fields[key] ?? {};
      if (typeof value !== 'object') continue;
      const fieldName = fields[key]?.field;
      if (fieldName !== undefined && fieldName in params) maxKeyStr = key;
    }
  }
  const maxKey = parseInt(maxKeyStr);

  // Special case for Ability to handle aoe and non-aoe.
  const abilityMessageType = `(?:${netlog_defs.Ability.messageType}|${netlog_defs.NetworkAOEAbility.messageType})`;
  const abilityHexCode = '(?:15|16)';

  // Build the regex from the fields.
  const prefix = defKey !== 'Ability' ? netlog_defs[defKey].messageType : abilityMessageType;

  // Hex codes are a minimum of two characters.  Abilities are special because
  // they need to support both 0x15 and 0x16.
  const typeAsHex = parseInt(netlog_defs[defKey].type).toString(16).toUpperCase();
  const defaultHexCode = typeAsHex.length < 2 ? `00${typeAsHex}`.slice(-2) : typeAsHex;
  const hexCode = defKey !== 'Ability' ? defaultHexCode : abilityHexCode;
  let str = '';
  if (capture) str += `(?<timestamp>\\y{Timestamp}) ${prefix} (?<type>${hexCode})`;else str += `\\y{Timestamp} ${prefix} ${hexCode}`;
  let lastKey = 1;
  for (const keyStr in fields) {
    const parseField = fields[keyStr];
    if (parseField === undefined) continue;
    const fieldName = parseField.field;

    // Regex handles these manually above in the `str` initialization.
    if (fieldName === 'timestamp' || fieldName === 'type') continue;
    const key = parseInt(keyStr);
    // Fill in blanks.
    const missingFields = key - lastKey - 1;
    if (missingFields === 1) str += `${separator}${matchDefault}`;else if (missingFields > 1) str += `(?:${separator}${matchDefault}){${missingFields}}`;
    lastKey = key;
    str += separator;
    if (typeof parseField !== 'object') throw new Error(`${defKey}: invalid value: ${JSON.stringify(parseField)}`);
    const fieldDefault = fieldName !== undefined && fieldsWithPotentialColons.includes(fieldName) ? matchWithColonsDefault : matchDefault;
    const defaultFieldValue = parseField.value?.toString() ?? fieldDefault;
    const fieldValue = params[fieldName];
    if (isRepeatingField(fields[keyStr]?.repeating, fieldValue)) {
      const repeatingFieldsSeparator = '(?:$|:)';
      let repeatingArray = fieldValue;
      const sortKeys = fields[keyStr]?.sortKeys;
      const primaryKey = fields[keyStr]?.primaryKey;
      const possibleKeys = fields[keyStr]?.possibleKeys;

      // primaryKey is required if this is a repeating field per typedef in netlog_defs.ts
      // Same with possibleKeys
      if (primaryKey === undefined || possibleKeys === undefined) throw new not_reached_UnreachableCode();

      // Allow sorting if needed
      if (sortKeys) {
        // Also sort our valid keys list
        possibleKeys.sort((left, right) => left.toLowerCase().localeCompare(right.toLowerCase()));
        if (repeatingArray !== undefined) {
          repeatingArray = [...repeatingArray].sort((left, right) => {
            // We check the validity of left/right because they're user-supplied
            if (typeof left !== 'object' || left[primaryKey] === undefined) {
              console.warn('Invalid argument passed to trigger:', left);
              return 0;
            }
            const leftValue = left[primaryKey];
            if (typeof leftValue !== 'string' || !possibleKeys?.includes(leftValue)) {
              console.warn('Invalid argument passed to trigger:', left);
              return 0;
            }
            if (typeof right !== 'object' || right[primaryKey] === undefined) {
              console.warn('Invalid argument passed to trigger:', right);
              return 0;
            }
            const rightValue = right[primaryKey];
            if (typeof rightValue !== 'string' || !possibleKeys?.includes(rightValue)) {
              console.warn('Invalid argument passed to trigger:', right);
              return 0;
            }
            return leftValue.toLowerCase().localeCompare(rightValue.toLowerCase());
          });
        }
      }
      const anonReps = repeatingArray;
      // Loop over our possible keys
      // Build a regex that can match any possible key with required values substituted in
      possibleKeys.forEach(possibleKey => {
        const rep = anonReps?.find(rep => primaryKey in rep && rep[primaryKey] === possibleKey);
        let fieldRegex = '';
        // Rather than looping over the keys defined on the object,
        // loop over the base type def's keys. This enforces the correct order.
        fields[keyStr]?.repeatingKeys?.forEach(key => {
          let val = rep?.[key];
          if (rep === undefined || !(key in rep)) {
            // If we don't have a value for this key
            // insert a placeholder, unless it's the primary key
            if (key === primaryKey) val = possibleKey;else val = matchDefault;
          }
          if (typeof val !== 'string') {
            if (!Array.isArray(val)) val = matchDefault;else if (val.length < 1) val = matchDefault;else if (val.some(v => typeof v !== 'string')) val = matchDefault;
          }
          fieldRegex += regexes_Regexes.maybeCapture(key === primaryKey ? false : capture,
          // All capturing groups are `fieldName` + `possibleKey`, e.g. `pairIsCasting1`
          fieldName + possibleKey, val, defaultFieldValue) + repeatingFieldsSeparator;
        });
        if (fieldRegex.length > 0) {
          str += `(?:${fieldRegex})${rep !== undefined ? '' : '?'}`;
        }
      });
    } else if (fields[keyStr]?.repeating) {
      // If this is a repeating field but the actual value is empty or otherwise invalid,
      // don't process further. We can't use `continue` in the above block because that
      // would skip the early-out break at the end of the loop.
    } else {
      if (fieldName !== undefined) {
        str += regexes_Regexes.maybeCapture(
        // more accurate type instead of `as` cast
        // maybe this function needs a refactoring
        capture, fieldName, fieldValue, defaultFieldValue);
      } else {
        str += fieldValue;
      }
    }

    // Stop if we're not capturing and don't care about future fields.
    if (key >= maxKey) break;
  }
  str += '(?:$|:)';
  return regexes_Regexes.parse(str);
};
const buildRegex = (type, params) => {
  return parseHelper(params, type, defaultParams(type, regexes_Regexes.logVersion));
};
class regexes_Regexes {
  static logVersion = 'latest';

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-20-0x14-networkstartscasting
   */
  static startsUsing(params) {
    return buildRegex('StartsUsing', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-21-0x15-networkability
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-22-0x16-networkaoeability
   */
  static ability(params) {
    return buildRegex('Ability', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-21-0x15-networkability
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-22-0x16-networkaoeability
   *
   * @deprecated Use `ability` instead
   */
  static abilityFull(params) {
    return this.ability(params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-27-0x1b-networktargeticon-head-marker
   */
  static headMarker(params) {
    return buildRegex('HeadMarker', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-03-0x03-addcombatant
   */
  static addedCombatant(params) {
    return buildRegex('AddedCombatant', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-03-0x03-addcombatant
   */
  static addedCombatantFull(params) {
    return this.addedCombatant(params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-04-0x04-removecombatant
   */
  static removingCombatant(params) {
    return buildRegex('RemovedCombatant', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-26-0x1a-networkbuff
   */
  static gainsEffect(params) {
    return buildRegex('GainsEffect', params);
  }

  /**
   * Prefer gainsEffect over this function unless you really need extra data.
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-38-0x26-networkstatuseffects
   */
  static statusEffectExplicit(params) {
    return buildRegex('StatusEffect', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-30-0x1e-networkbuffremove
   */
  static losesEffect(params) {
    return buildRegex('LosesEffect', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-35-0x23-networktether
   */
  static tether(params) {
    return buildRegex('Tether', params);
  }

  /**
   * 'target' was defeated by 'source'
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-25-0x19-networkdeath
   */
  static wasDefeated(params) {
    return buildRegex('WasDefeated', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-24-0x18-networkdot
   */
  static networkDoT(params) {
    return buildRegex('NetworkDoT', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-00-0x00-logline
   */
  static echo(params) {
    if (typeof params === 'undefined') params = {};
    regexes_Regexes.validateParams(params, 'echo', ['type', 'timestamp', 'code', 'name', 'line', 'capture']);
    params.code = '0038';
    return regexes_Regexes.gameLog(params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-00-0x00-logline
   */
  static dialog(params) {
    if (typeof params === 'undefined') params = {};
    regexes_Regexes.validateParams(params, 'dialog', ['type', 'timestamp', 'code', 'name', 'line', 'capture']);
    params.code = '0044';
    return regexes_Regexes.gameLog(params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-00-0x00-logline
   */
  static message(params) {
    if (typeof params === 'undefined') params = {};
    regexes_Regexes.validateParams(params, 'message', ['type', 'timestamp', 'code', 'name', 'line', 'capture']);
    params.code = '0839';
    return regexes_Regexes.gameLog(params);
  }

  /**
   * fields: code, name, line, capture
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-00-0x00-logline
   */
  static gameLog(params) {
    return buildRegex('GameLog', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-00-0x00-logline
   */
  static gameNameLog(params) {
    // Backwards compatability.
    return regexes_Regexes.gameLog(params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-12-0x0c-playerstats
   */
  static statChange(params) {
    return buildRegex('PlayerStats', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-01-0x01-changezone
   */
  static changeZone(params) {
    return buildRegex('ChangeZone', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-33-0x21-network6d-actor-control
   */
  static network6d(params) {
    return buildRegex('ActorControl', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-34-0x22-networknametoggle
   */
  static nameToggle(params) {
    return buildRegex('NameToggle', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-40-0x28-map
   */
  static map(params) {
    return buildRegex('Map', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-41-0x29-systemlogmessage
   */
  static systemLogMessage(params) {
    return buildRegex('SystemLogMessage', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-257-0x101-mapeffect
   */
  static mapEffect(params) {
    return buildRegex('MapEffect', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-261-0x105-combatantmemory
   */
  static combatantMemory(params) {
    return buildRegex('CombatantMemory', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-263-0x107-startsusingextra
   */
  static startsUsingExtra(params) {
    return buildRegex('StartsUsingExtra', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-264-0x108-abilityextra
   */
  static abilityExtra(params) {
    return buildRegex('AbilityExtra', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-265-0x109-contentfindersettings
   */
  static contentFinderSettings(params) {
    return buildRegex('ContentFinderSettings', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-266-0x10a-npcyell
   */
  static npcYell(params) {
    return buildRegex('NpcYell', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-267-0x10b-battletalk2
   */
  static battleTalk2(params) {
    return buildRegex('BattleTalk2', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-268-0x10c-countdown
   */
  static countdown(params) {
    return buildRegex('Countdown', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-269-0x10d-countdowncancel
   */
  static countdownCancel(params) {
    return buildRegex('CountdownCancel', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-270-0x10e-actormove
   */
  static actorMove(params) {
    return buildRegex('ActorMove', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-271-0x10f-actorsetpos
   */
  static actorSetPos(params) {
    return buildRegex('ActorSetPos', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-272-0x110-spawnnpcextra
   */
  static spawnNpcExtra(params) {
    return buildRegex('SpawnNpcExtra', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-273-0x111-actorcontrolextra
   */
  static actorControlExtra(params) {
    return buildRegex('ActorControlExtra', params);
  }

  /**
   * Helper function for building named capture group
   */
  static maybeCapture(capture, name, value, defaultValue) {
    if (value === undefined) value = defaultValue ?? matchDefault;
    value = regexes_Regexes.anyOf(value);
    return capture ? regexes_Regexes.namedCapture(name, value) : value;
  }
  static optional(str) {
    return `(?:${str})?`;
  }

  // Creates a named regex capture group named |name| for the match |value|.
  static namedCapture(name, value) {
    if (name.includes('>')) console.error(`"${name}" contains ">".`);
    if (name.includes('<')) console.error(`"${name}" contains ">".`);
    return `(?<${name}>${value})`;
  }

  /**
   * Convenience for turning multiple args into a unioned regular expression.
   * anyOf(x, y, z) or anyOf([x, y, z]) do the same thing, and return (?:x|y|z).
   * anyOf(x) or anyOf(x) on its own simplifies to just x.
   * args may be strings or RegExp, although any additional markers to RegExp
   * like /insensitive/i are dropped.
   */
  static anyOf(...args) {
    const anyOfArray = array => {
      const [elem] = array;
      if (elem !== undefined && array.length === 1) return `${elem instanceof RegExp ? elem.source : elem}`;
      return `(?:${array.map(elem => elem instanceof RegExp ? elem.source : elem).join('|')})`;
    };
    let array = [];
    const [firstArg] = args;
    if (args.length === 1) {
      if (typeof firstArg === 'string' || firstArg instanceof RegExp) array = [firstArg];else if (Array.isArray(firstArg)) array = firstArg;else array = [];
    } else {
      // TODO: more accurate type instead of `as` cast
      array = args;
    }
    return anyOfArray(array);
  }
  static parse(regexpString) {
    const kCactbotCategories = {
      Timestamp: '^.{14}',
      NetTimestamp: '.{33}',
      NetField: '(?:[^|]*\\|)',
      LogType: '[0-9A-Fa-f]{2}',
      AbilityCode: '[0-9A-Fa-f]{1,8}',
      ObjectId: '[0-9A-F]{8}',
      // Matches any character name (including empty strings which the FFXIV
      // ACT plugin can generate when unknown).
      Name: '(?:[^\\s:|]+(?: [^\\s:|]+)?|)',
      // Floats can have comma as separator in FFXIV plugin output: https://github.com/ravahn/FFXIV_ACT_Plugin/issues/137
      Float: '-?[0-9]+(?:[.,][0-9]+)?(?:E-?[0-9]+)?'
    };

    // All regexes in cactbot are case insensitive.
    // This avoids headaches as things like `Vice and Vanity` turns into
    // `Vice And Vanity`, especially for French and German.  It appears to
    // have a ~20% regex parsing overhead, but at least they work.
    let modifiers = 'i';
    if (regexpString instanceof RegExp) {
      modifiers += (regexpString.global ? 'g' : '') + (regexpString.multiline ? 'm' : '');
      regexpString = regexpString.source;
    }
    regexpString = regexpString.replace(/\\y\{(.*?)\}/g, (match, group) => {
      return kCactbotCategories[group] || match;
    });
    return new RegExp(regexpString, modifiers);
  }

  // Like Regex.Regexes.parse, but force global flag.
  static parseGlobal(regexpString) {
    const regex = regexes_Regexes.parse(regexpString);
    let modifiers = 'gi';
    if (regexpString instanceof RegExp) modifiers += regexpString.multiline ? 'm' : '';
    return new RegExp(regex.source, modifiers);
  }
  static trueIfUndefined(value) {
    if (typeof value === 'undefined') return true;
    return !!value;
  }
  static validateParams(f, funcName, params) {
    if (f === null) return;
    if (typeof f !== 'object') return;
    const keys = Object.keys(f);
    for (const key of keys) {
      if (!params.includes(key)) {
        throw new Error(`${funcName}: invalid parameter '${key}'.  ` + `Valid params: ${JSON.stringify(params)}`);
      }
    }
  }
}
;// CONCATENATED MODULE: ./resources/netregexes.ts



const netregexes_separator = '\\|';
const netregexes_matchDefault = '[^|]*';

// If NetRegexes.setFlagTranslationsNeeded is set to true, then any
// regex created that requires a translation will begin with this string
// and match the magicStringRegex.  This is maybe a bit goofy, but is
// a pretty straightforward way to mark regexes for translations.
// If issue #1306 is ever resolved, we can remove this.
const magicTranslationString = `^^`;
const magicStringRegex = /^\^\^/;

// can't simply export this, see https://github.com/OverlayPlugin/cactbot/pull/4957#discussion_r1002590589
const keysThatRequireTranslationAsConst = ['ability', 'name', 'source', 'target', 'line'];
const netregexes_keysThatRequireTranslation = keysThatRequireTranslationAsConst;
const gameLogCodes = {
  echo: '0038',
  dialog: '0044',
  message: '0839'
};
const netregexes_defaultParams = (type, version, include) => {
  const logType = logDefinitionsVersions[version][type];
  if (include === undefined) {
    include = Object.keys(logType.fields);
    if ('repeatingFields' in logType) {
      include.push(logType.repeatingFields.label);
    }
  }
  const params = {};
  const firstOptionalField = logType.firstOptionalField;
  for (const [prop, index] of Object.entries(logType.fields)) {
    if (!include.includes(prop)) continue;
    const param = {
      field: prop,
      optional: firstOptionalField !== undefined && index >= firstOptionalField
    };
    if (prop === 'type') param.value = logType.type;
    params[index] = param;
  }
  if ('repeatingFields' in logType && include.includes(logType.repeatingFields.label)) {
    params[logType.repeatingFields.startingIndex] = {
      field: logType.repeatingFields.label,
      optional: firstOptionalField !== undefined && logType.repeatingFields.startingIndex >= firstOptionalField,
      repeating: true,
      repeatingKeys: [...logType.repeatingFields.names],
      sortKeys: logType.repeatingFields.sortKeys,
      primaryKey: logType.repeatingFields.primaryKey,
      possibleKeys: [...logType.repeatingFields.possibleKeys]
    };
  }
  return params;
};
const netregexes_isRepeatingField = (repeating, value) => {
  if (repeating !== true) return false;
  // Allow excluding the field to match for extraction
  if (value === undefined) return true;
  if (!Array.isArray(value)) return false;
  for (const e of value) {
    if (typeof e !== 'object') return false;
  }
  return true;
};
const netregexes_parseHelper = (params, funcName, fields) => {
  params = params ?? {};
  const validFields = [];
  for (const index in fields) {
    const field = fields[index];
    if (field) validFields.push(field.field);
  }
  regexes_Regexes.validateParams(params, funcName, ['capture', ...validFields]);

  // Find the last key we care about, so we can shorten the regex if needed.
  const capture = regexes_Regexes.trueIfUndefined(params.capture);
  const fieldKeys = Object.keys(fields).sort((a, b) => parseInt(a) - parseInt(b));
  let maxKeyStr;
  if (capture) {
    const keys = [];
    for (const key in fields) keys.push(key);
    let tmpKey = keys.pop();
    if (tmpKey === undefined) {
      maxKeyStr = fieldKeys[fieldKeys.length - 1] ?? '0';
    } else {
      while (fields[tmpKey]?.optional && !((fields[tmpKey]?.field ?? '') in params)) tmpKey = keys.pop();
      maxKeyStr = tmpKey ?? '0';
    }
  } else {
    maxKeyStr = '0';
    for (const key in fields) {
      const value = fields[key] ?? {};
      if (typeof value !== 'object') continue;
      const fieldName = fields[key]?.field;
      if (fieldName !== undefined && fieldName in params) maxKeyStr = key;
    }
  }
  const maxKey = parseInt(maxKeyStr);

  // For testing, it's useful to know if this is a regex that requires
  // translation.  We test this by seeing if there are any specified
  // fields, and if so, inserting a magic string that we can detect.
  // This lets us differentiate between "regex that should be translated"
  // e.g. a regex with `target` specified, and "regex that shouldn't"
  // e.g. a gains effect with just effectId specified.
  const transParams = Object.keys(params).filter(k => netregexes_keysThatRequireTranslation.includes(k));
  const needsTranslations = NetRegexes.flagTranslationsNeeded && transParams.length > 0;

  // Build the regex from the fields.
  let str = needsTranslations ? magicTranslationString : '^';
  let lastKey = -1;
  for (const keyStr in fields) {
    const key = parseInt(keyStr);
    // Fill in blanks.
    const missingFields = key - lastKey - 1;
    if (missingFields === 1) str += '\\y{NetField}';else if (missingFields > 1) str += `\\y{NetField}{${missingFields}}`;
    lastKey = key;
    const value = fields[keyStr];
    if (typeof value !== 'object') throw new Error(`${funcName}: invalid value: ${JSON.stringify(value)}`);
    const fieldName = value.field;
    const defaultFieldValue = value.value?.toString() ?? netregexes_matchDefault;
    const fieldValue = params[fieldName];
    if (netregexes_isRepeatingField(fields[keyStr]?.repeating, fieldValue)) {
      let repeatingArray = fieldValue;
      const sortKeys = fields[keyStr]?.sortKeys;
      const primaryKey = fields[keyStr]?.primaryKey;
      const possibleKeys = fields[keyStr]?.possibleKeys;

      // primaryKey is required if this is a repeating field per typedef in netlog_defs.ts
      // Same with possibleKeys
      if (primaryKey === undefined || possibleKeys === undefined) throw new not_reached_UnreachableCode();

      // Allow sorting if needed
      if (sortKeys) {
        // Also sort our valid keys list
        possibleKeys.sort((left, right) => left.toLowerCase().localeCompare(right.toLowerCase()));
        if (repeatingArray !== undefined) {
          repeatingArray = [...repeatingArray].sort((left, right) => {
            // We check the validity of left/right because they're user-supplied
            if (typeof left !== 'object' || left[primaryKey] === undefined) {
              console.warn('Invalid argument passed to trigger:', left);
              return 0;
            }
            const leftValue = left[primaryKey];
            if (typeof leftValue !== 'string' || !possibleKeys?.includes(leftValue)) {
              console.warn('Invalid argument passed to trigger:', left);
              return 0;
            }
            if (typeof right !== 'object' || right[primaryKey] === undefined) {
              console.warn('Invalid argument passed to trigger:', right);
              return 0;
            }
            const rightValue = right[primaryKey];
            if (typeof rightValue !== 'string' || !possibleKeys?.includes(rightValue)) {
              console.warn('Invalid argument passed to trigger:', right);
              return 0;
            }
            return leftValue.toLowerCase().localeCompare(rightValue.toLowerCase());
          });
        }
      }
      const anonReps = repeatingArray;
      // Loop over our possible keys
      // Build a regex that can match any possible key with required values substituted in
      possibleKeys.forEach(possibleKey => {
        const rep = anonReps?.find(rep => primaryKey in rep && rep[primaryKey] === possibleKey);
        let fieldRegex = '';
        // Rather than looping over the keys defined on the object,
        // loop over the base type def's keys. This enforces the correct order.
        fields[keyStr]?.repeatingKeys?.forEach(key => {
          let val = rep?.[key];
          if (rep === undefined || !(key in rep)) {
            // If we don't have a value for this key
            // insert a placeholder, unless it's the primary key
            if (key === primaryKey) val = possibleKey;else val = netregexes_matchDefault;
          }
          if (typeof val !== 'string') {
            if (!Array.isArray(val)) val = netregexes_matchDefault;else if (val.length < 1) val = netregexes_matchDefault;else if (val.some(v => typeof v !== 'string')) val = netregexes_matchDefault;
          }
          fieldRegex += regexes_Regexes.maybeCapture(key === primaryKey ? false : capture,
          // All capturing groups are `fieldName` + `possibleKey`, e.g. `pairIsCasting1`
          fieldName + possibleKey, val, defaultFieldValue) + netregexes_separator;
        });
        if (fieldRegex.length > 0) {
          str += `(?:${fieldRegex})${rep !== undefined ? '' : '?'}`;
        }
      });
    } else if (fields[keyStr]?.repeating) {
      // If this is a repeating field but the actual value is empty or otherwise invalid,
      // don't process further. We can't use `continue` in the above block because that
      // would skip the early-out break at the end of the loop.
    } else {
      if (fieldName !== undefined) {
        str += regexes_Regexes.maybeCapture(
        // more accurate type instead of `as` cast
        // maybe this function needs a refactoring
        capture, fieldName, fieldValue, defaultFieldValue) + netregexes_separator;
      } else {
        str += defaultFieldValue + netregexes_separator;
      }
    }

    // Stop if we're not capturing and don't care about future fields.
    if (key >= maxKey) break;
  }
  return regexes_Regexes.parse(str);
};
const netregexes_buildRegex = (type, params) => {
  return netregexes_parseHelper(params, type, netregexes_defaultParams(type, NetRegexes.logVersion));
};
class NetRegexes {
  static logVersion = 'latest';
  static flagTranslationsNeeded = false;
  static setFlagTranslationsNeeded(value) {
    NetRegexes.flagTranslationsNeeded = value;
  }
  static doesNetRegexNeedTranslation(regex) {
    // Need to `setFlagTranslationsNeeded` before calling this function.
    console.assert(NetRegexes.flagTranslationsNeeded);
    const str = typeof regex === 'string' ? regex : regex.source;
    return !!magicStringRegex.exec(str);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-20-0x14-networkstartscasting
   */
  static startsUsing(params) {
    return netregexes_buildRegex('StartsUsing', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-21-0x15-networkability
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-22-0x16-networkaoeability
   */
  static ability(params) {
    return netregexes_parseHelper(params, 'Ability', {
      ...netregexes_defaultParams('Ability', NetRegexes.logVersion),
      // Override type
      0: {
        field: 'type',
        value: '2[12]',
        optional: false
      }
    });
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-21-0x15-networkability
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-22-0x16-networkaoeability
   *
   * @deprecated Use `ability` instead
   */
  static abilityFull(params) {
    return this.ability(params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-27-0x1b-networktargeticon-head-marker
   */
  static headMarker(params) {
    return netregexes_buildRegex('HeadMarker', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-03-0x03-addcombatant
   */
  static addedCombatant(params) {
    return netregexes_parseHelper(params, 'AddedCombatant', netregexes_defaultParams('AddedCombatant', NetRegexes.logVersion));
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-03-0x03-addcombatant
   * @deprecated Use `addedCombatant` instead
   */
  static addedCombatantFull(params) {
    return NetRegexes.addedCombatant(params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-04-0x04-removecombatant
   */
  static removingCombatant(params) {
    return netregexes_buildRegex('RemovedCombatant', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-26-0x1a-networkbuff
   */
  static gainsEffect(params) {
    return netregexes_buildRegex('GainsEffect', params);
  }

  /**
   * Prefer gainsEffect over this function unless you really need extra data.
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-38-0x26-networkstatuseffects
   */
  static statusEffectExplicit(params) {
    return netregexes_buildRegex('StatusEffect', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-30-0x1e-networkbuffremove
   */
  static losesEffect(params) {
    return netregexes_buildRegex('LosesEffect', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-35-0x23-networktether
   */
  static tether(params) {
    return netregexes_buildRegex('Tether', params);
  }

  /**
   * 'target' was defeated by 'source'
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-25-0x19-networkdeath
   */
  static wasDefeated(params) {
    return netregexes_buildRegex('WasDefeated', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-24-0x18-networkdot
   */
  static networkDoT(params) {
    return netregexes_buildRegex('NetworkDoT', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-00-0x00-logline
   */
  static echo(params) {
    if (typeof params === 'undefined') params = {};
    regexes_Regexes.validateParams(params, 'Echo', ['type', 'timestamp', 'code', 'name', 'line', 'capture']);
    return NetRegexes.gameLog({
      ...params,
      code: gameLogCodes.echo
    });
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-00-0x00-logline
   */
  static dialog(params) {
    if (typeof params === 'undefined') params = {};
    regexes_Regexes.validateParams(params, 'Dialog', ['type', 'timestamp', 'code', 'name', 'line', 'capture']);
    return NetRegexes.gameLog({
      ...params,
      code: gameLogCodes.dialog
    });
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-00-0x00-logline
   */
  static message(params) {
    if (typeof params === 'undefined') params = {};
    regexes_Regexes.validateParams(params, 'Message', ['type', 'timestamp', 'code', 'name', 'line', 'capture']);
    return NetRegexes.gameLog({
      ...params,
      code: gameLogCodes.message
    });
  }

  /**
   * fields: code, name, line, capture
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-00-0x00-logline
   */
  static gameLog(params) {
    return netregexes_buildRegex('GameLog', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-00-0x00-logline
   */
  static gameNameLog(params) {
    // Backwards compatability.
    return NetRegexes.gameLog(params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-12-0x0c-playerstats
   */
  static statChange(params) {
    return netregexes_buildRegex('PlayerStats', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-01-0x01-changezone
   */
  static changeZone(params) {
    return netregexes_buildRegex('ChangeZone', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-33-0x21-network6d-actor-control
   */
  static network6d(params) {
    return netregexes_buildRegex('ActorControl', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-34-0x22-networknametoggle
   */
  static nameToggle(params) {
    return netregexes_buildRegex('NameToggle', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-40-0x28-map
   */
  static map(params) {
    return netregexes_buildRegex('Map', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-41-0x29-systemlogmessage
   */
  static systemLogMessage(params) {
    return netregexes_buildRegex('SystemLogMessage', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-257-0x101-mapeffect
   */
  static mapEffect(params) {
    return netregexes_buildRegex('MapEffect', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-258-0x102-fatedirector
   */
  static fateDirector(params) {
    return netregexes_buildRegex('FateDirector', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-259-0x103-cedirector
   */
  static ceDirector(params) {
    return netregexes_buildRegex('CEDirector', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-260-0x104-incombat
   */
  static inCombat(params) {
    return netregexes_buildRegex('InCombat', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-261-0x105-combatantmemory
   */
  static combatantMemory(params) {
    return netregexes_buildRegex('CombatantMemory', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-263-0x107-startsusingextra
   */
  static startsUsingExtra(params) {
    return netregexes_buildRegex('StartsUsingExtra', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-264-0x108-abilityextra
   */
  static abilityExtra(params) {
    return netregexes_buildRegex('AbilityExtra', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-265-0x109-contentfindersettings
   */
  static contentFinderSettings(params) {
    return netregexes_buildRegex('ContentFinderSettings', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-266-0x10a-npcyell
   */
  static npcYell(params) {
    return netregexes_buildRegex('NpcYell', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-267-0x10b-battletalk2
   */
  static battleTalk2(params) {
    return netregexes_buildRegex('BattleTalk2', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-268-0x10c-countdown
   */
  static countdown(params) {
    return netregexes_buildRegex('Countdown', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-269-0x10d-countdowncancel
   */
  static countdownCancel(params) {
    return netregexes_buildRegex('CountdownCancel', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-270-0x10e-actormove
   */
  static actorMove(params) {
    return netregexes_buildRegex('ActorMove', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-271-0x10f-actorsetpos
   */
  static actorSetPos(params) {
    return netregexes_buildRegex('ActorSetPos', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-272-0x110-spawnnpcextra
   */
  static spawnNpcExtra(params) {
    return netregexes_buildRegex('SpawnNpcExtra', params);
  }

  /**
   * matches: https://github.com/OverlayPlugin/cactbot/blob/main/docs/LogGuide.md#line-273-0x111-actorcontrolextra
   */
  static actorControlExtra(params) {
    return netregexes_buildRegex('ActorControlExtra', params);
  }
}
const commonNetRegex = {
  // TODO(6.2): remove 40000010 after everybody is on 6.2.
  // TODO: or maybe keep around for playing old log files??
  wipe: NetRegexes.network6d({
    command: ['40000010', '4000000F']
  }),
  cactbotWipeEcho: NetRegexes.echo({
    line: 'cactbot wipe.*?'
  }),
  userWipeEcho: NetRegexes.echo({
    line: 'end'
  })
};
const buildNetRegexForTrigger = (type, params) => {
  if (type === 'Ability')
    // ts can't narrow T to `Ability` here, need casting.
    return NetRegexes.ability(params);
  return netregexes_buildRegex(type, params);
};
;// CONCATENATED MODULE: ./ui/raidboss/common_replacement.ts
// TODO: maybe this should be structured identically to a timelineReplace section.

// The seal key is kind of a hack because we use it in a lot of different
// contexts and need to correctly grab the name of the zone that is sealed.
// These are some various lookbehinds for those different contexts:
// Regexes for a parsed ACT log line
const parsedLB = '00:0839::';
// Regexes for a network log line
const networkLB = '00\\|[^|]*\\|0839\\|\\|';
// Regex for a regex for a network log line.  <_<
const netRegexLB = '\\\\\\|0839\\\\\\|\\[\\^\\|\\]\\*\\\\\\|';
// A bare parameter (e.g. `X will be sealed off` via `netRegex: { line: 'X will be sealed off' },`)
const paramLB = '^';

// It's awkward to refer to these string keys, so name them as replaceSync[keys.sealKey].
const syncKeys = {
  // Seal is trying to match these types of lines, and is more complicated because it's
  // trying to also capture the area name:
  //   parsed log lines: 00:0839::Something will be sealed off
  //   network log lines: 00|timestamp|0839||Something will be sealed off
  //   NetRegexes: ^^00\|[^|]*\|0839\|[^|]*\|Something will be sealed off.*?\|
  seal: `(?<=${parsedLB}|${networkLB}|${netRegexLB}|${paramLB})([^|:]*) will be sealed off(?: in (?:[0-9]+ seconds)?)?`,
  unseal: 'is no longer sealed',
  engage: 'Engage!'
};
const textKeys = {
  // Match directions in replaceText
  // eg: `(N)`, `(SW)`, `(NE/NW)`, etc.
  E: '(?<= \\(|\\/)E(?=\\)|\\/)',
  N: '(?<= \\(|\\/)N(?=\\)|\\/)',
  S: '(?<= \\(|\\/)S(?=\\)|\\/)',
  W: '(?<= \\(|\\/)W(?=\\)|\\/)',
  NE: '(?<= \\(|\\/)NE(?=\\)|\\/)',
  NW: '(?<= \\(|\\/)NW(?=\\)|\\/)',
  SE: '(?<= \\(|\\/)SE(?=\\)|\\/)',
  SW: '(?<= \\(|\\/)SW(?=\\)|\\/)',
  // Match Roles in replaceText
  // eg: `(Tank)`, `(Healer)`, `(DPS)`, etc
  Tank: '(?<= \\(|\\/)Tanks?(?=\\)|\\/)',
  Healer: '(?<= \\(|\\/)Healers?(?=\\)|\\/)',
  DPS: '(?<= \\(|\\/)DPS(?=\\)|\\/)',
  // Match `--1--` style text.
  Number: '--(\\s*\\d+\\s*)--'
};
const common_replacement_commonReplacement = {
  replaceSync: {
    [syncKeys.seal]: {
      en: '$1 will be sealed off',
      de: 'Noch 15 Sekunden, bis sich (?:(?:der|die|das) )?(?:Zugang zu(?:[rm]| den)? )?$1 schließt',
      fr: 'Fermeture d(?:e|u|es) (?:l\'|la |les? )?$1 dans',
      ja: '$1の封鎖まであと',
      cn: '距$1被封锁还有',
      ko: '15초 후에 $1[이가] 봉쇄됩니다'
    },
    [syncKeys.unseal]: {
      en: 'is no longer sealed',
      de: 'öffnet sich (?:wieder|erneut)',
      fr: 'Ouverture ',
      ja: 'の封鎖が解かれた',
      cn: '的封锁解除了',
      ko: '의 봉쇄가 해제되었습니다'
    },
    [syncKeys.engage]: {
      en: 'Engage!',
      de: 'Start!',
      fr: 'À l\'attaque',
      ja: '戦闘開始！',
      cn: '战斗开始！',
      ko: '전투 시작!'
    }
  },
  replaceText: {
    '--adds spawn--': {
      de: '--Adds erscheinen--',
      fr: '--Apparition d\'adds--',
      ja: '--雑魚出現--',
      cn: '--小怪出现--',
      ko: '--쫄 소환--'
    },
    '--adds targetable--': {
      de: '--Adds anvisierbar--',
      fr: '--Adds ciblables--',
      ja: '--雑魚ターゲット可能--',
      cn: '--小怪可选中--',
      ko: '--쫄 타겟 가능--'
    },
    '--center--': {
      de: '--Mitte--',
      fr: '--Centre--',
      ja: '--センター--',
      cn: '--中央--',
      ko: '--중앙--'
    },
    '\\(center\\)': {
      de: '(Mitte)',
      fr: '(Centre)',
      ja: '(センター)',
      cn: '(中央)',
      ko: '(중앙)'
    },
    '--clones appear--': {
      de: '--Klone erscheinen--',
      fr: '--Apparition des clones--',
      ja: '--幻影出現--',
      cn: '--幻影出现--',
      ko: '--분신 소환--'
    },
    '--corner--': {
      de: '--Ecke--',
      fr: '--Coin--',
      ja: '--コーナー--',
      cn: '--角落--',
      ko: '--구석--'
    },
    '--dps burn--': {
      de: '--DPS burn--',
      fr: '--Burn dps--',
      ja: '--火力出せ--',
      cn: '--转火--',
      ko: '--딜 체크--'
    },
    '--east--': {
      de: '--Osten--',
      fr: '--Est--',
      ja: '--東--',
      cn: '--东--',
      ko: '--동쪽--'
    },
    '\\(east\\)': {
      de: '(Osten)',
      fr: '(Est)',
      ja: '(東)',
      cn: '(东)',
      ko: '(동쪽)'
    },
    'Enrage': {
      de: 'Finalangriff',
      fr: 'Enrage',
      ja: '時間切れ',
      cn: '狂暴',
      ko: '전멸기'
    },
    '--frozen--': {
      de: '--eingefroren--',
      fr: '--Gelé--',
      ja: '--凍結--',
      cn: '--冻结--',
      ko: '--빙결--'
    },
    '--in--': {
      de: '--Rein--',
      fr: '--Intérieur--',
      ja: '--中--',
      cn: '--内--',
      ko: '--안--'
    },
    '\\(In\\)': {
      de: '(Rein)',
      fr: '(Intérieur)',
      ja: '(中)',
      cn: '(内)',
      ko: '(안)'
    },
    '\\(inner\\)': {
      de: '(innen)',
      fr: '(intérieur)',
      ja: '(中)',
      cn: '(内)',
      ko: '(안)'
    },
    '--jump--': {
      de: '--Sprung--',
      fr: '--Saut--',
      ja: '--ジャンプ--',
      cn: '--跳--',
      ko: '--점프--'
    },
    '--knockback--': {
      de: '--Rückstoß--',
      fr: '--Poussée--',
      ja: '--ノックバック--',
      cn: '--击退--',
      ko: '--넉백--'
    },
    '--middle--': {
      de: '--Mitte--',
      fr: '--Milieu--',
      ja: '--中央--',
      cn: '--中间--',
      ko: '--중앙--'
    },
    '\\(middle\\)': {
      de: '(Mitte)',
      fr: '(Milieu)',
      ja: '(中央)',
      cn: '(中间)',
      ko: '(중앙)'
    },
    '--north--': {
      de: '--Norden--',
      fr: '--Nord--',
      ja: '--北--',
      cn: '--北--',
      ko: '--북쪽--'
    },
    '\\(north\\)': {
      de: '(Norden)',
      fr: '(Nord)',
      ja: '(北)',
      cn: '(北)',
      ko: '(북쪽)'
    },
    '--northeast--': {
      de: '--Nordosten--',
      fr: '--Nord-Est--',
      ja: '--北東--',
      cn: '--东北--',
      ko: '--북동--'
    },
    '--northwest--': {
      de: '--Nordwesten--',
      fr: '--Nord-Ouest--',
      ja: '--北西--',
      cn: '--西北--',
      ko: '--북서--'
    },
    '--out--': {
      de: '--Raus--',
      fr: '--Extérieur--',
      ja: '--外--',
      cn: '--外--',
      ko: '--밖--'
    },
    '\\(Out\\)': {
      de: '(Raus)',
      fr: '(Extérieur)',
      ja: '(外)',
      cn: '(外)',
      ko: '(밖)'
    },
    '\\(outer\\)': {
      de: '(außen)',
      fr: '(extérieur)',
      ja: '(外)',
      cn: '(外)',
      ko: '(밖)'
    },
    '\\(outside\\)': {
      de: '(Draußen)',
      fr: '(À l\'extérieur)',
      ja: '(外)',
      cn: '(外面)',
      ko: '(바깥)'
    },
    '--rotate--': {
      de: '--rotieren--',
      fr: '--rotation--',
      ja: '--回転--',
      cn: '--旋转--',
      ko: '--회전--'
    },
    '--south--': {
      de: '--Süden--',
      fr: '--Sud--',
      ja: '--南--',
      cn: '--南--',
      ko: '--남쪽--'
    },
    '\\(south\\)': {
      de: '(Süden)',
      fr: '(Sud)',
      ja: '(南)',
      cn: '(南)',
      ko: '(남쪽)'
    },
    '--southeast--': {
      de: '--Südosten--',
      fr: '--Sud-Est--',
      ja: '--南東--',
      cn: '--东南--',
      ko: '--남동--'
    },
    '--southwest--': {
      de: '--Südwesten--',
      fr: '--Sud-Ouest--',
      ja: '--南西--',
      cn: '--西南--',
      ko: '--남서--'
    },
    '--split--': {
      de: '--teilen--',
      fr: '--division--',
      ja: '--分裂--',
      cn: '--分裂--',
      ko: '--분열--'
    },
    '--stun--': {
      de: '--Betäubung--',
      fr: '--Étourdissement--',
      ja: '--スタン--',
      cn: '--击晕--',
      ko: '--기절--'
    },
    '--sync--': {
      de: '--synchronisation--',
      fr: '--synchronisation--',
      ja: '--シンク--',
      cn: '--同步化--',
      ko: '--동기화--'
    },
    '--([0-9]+x )?targetable--': {
      de: '--$1anvisierbar--',
      fr: '--$1ciblable--',
      ja: '--$1ターゲット可能--',
      cn: '--$1可选中--',
      ko: '--$1타겟 가능--'
    },
    '--teleport--': {
      de: '--teleportation--',
      fr: '--téléportation--',
      ja: '--テレポート--',
      cn: '--传送--',
      ko: '--순간 이동--'
    },
    '--untargetable--': {
      de: '--nich anvisierbar--',
      fr: '--non ciblable--',
      ja: '--ターゲット不可--',
      cn: '--无法选中--',
      ko: '--타겟 불가능--'
    },
    '--west--': {
      de: '--Westen--',
      fr: '--Ouest--',
      ja: '--西--',
      cn: '--西--',
      ko: '--서쪽--'
    },
    [textKeys.E]: {
      de: 'O',
      fr: 'E',
      ja: '東',
      cn: '东',
      ko: '동'
    },
    [textKeys.N]: {
      de: 'N',
      fr: 'N',
      ja: '北',
      cn: '北',
      ko: '북'
    },
    [textKeys.S]: {
      de: 'S',
      fr: 'S',
      ja: '南',
      cn: '南',
      ko: '남'
    },
    [textKeys.W]: {
      de: 'W',
      fr: 'O',
      ja: '西',
      cn: '西',
      ko: '서'
    },
    [textKeys.NE]: {
      de: 'NO',
      fr: 'NE',
      ja: '北東',
      cn: '东北',
      ko: '북동'
    },
    [textKeys.NW]: {
      de: 'NW',
      fr: 'NO',
      ja: '北西',
      cn: '西北',
      ko: '북서'
    },
    [textKeys.SE]: {
      de: 'SO',
      fr: 'SE',
      ja: '南東',
      cn: '东南',
      ko: '남동'
    },
    [textKeys.SW]: {
      de: 'SW',
      fr: 'SO',
      ja: '南西',
      cn: '西南',
      ko: '남서'
    },
    [textKeys.Tank]: {
      de: 'Tank',
      fr: 'Tank',
      ja: 'タンク',
      cn: '坦克',
      ko: '탱커'
    },
    [textKeys.Healer]: {
      de: 'Heiler',
      fr: 'Healer',
      ja: 'ヒーラー',
      cn: '治疗',
      ko: '힐러'
    },
    [textKeys.DPS]: {
      de: 'DPS',
      fr: 'DPS',
      ja: 'DPS',
      cn: 'DPS',
      ko: '딜러'
    },
    [textKeys.Number]: {
      de: '--$1--',
      fr: '--$1--',
      ja: '--$1--',
      cn: '--$1--',
      ko: '--$1--'
    }
  }
};

// Keys into commonReplacement objects that represent "partial" translations,
// in the sense that even if it applies, there still needs to be another
// translation for it to be complete.  These keys should be exactly the same
// as the keys from the commonReplacement block above.  These are used for
// timeline regexes only.
const common_replacement_partialCommonTimelineReplacementKeys = [
// Because the zone name needs to be translated here, this is partial.
syncKeys.seal,
// Directions
textKeys.E, textKeys.N, textKeys.S, textKeys.W, textKeys.NE, textKeys.NW, textKeys.SE, textKeys.SW,
// Roles
textKeys.Tank, textKeys.Healer, textKeys.DPS];

// Same as the timeline version above, but only for trigger regexes.
const common_replacement_partialCommonTriggerReplacementKeys = [
// Because the zone name needs to be translated here, this is partial.
syncKeys.seal];
;// CONCATENATED MODULE: ./resources/translations.ts




// Fill in LocaleRegex so that things like LocaleRegex.countdownStart.de is a valid regex.
const localeLines = {
  countdownStart: {
    en: 'Battle commencing in (?<time>\\y{Float}) seconds! \\((?<player>.*?)\\)',
    de: 'Noch (?<time>\\y{Float}) Sekunden bis Kampfbeginn! \\((?<player>.*?)\\)',
    fr: 'Début du combat dans (?<time>\\y{Float}) secondes[ ]?! \\((?<player>.*?)\\)',
    ja: '戦闘開始まで(?<time>\\y{Float})秒！ （(?<player>.*?)）',
    cn: '距离战斗开始还有(?<time>\\y{Float})秒！ （(?<player>.*?)）',
    ko: '전투 시작 (?<time>\\y{Float})초 전! \\((?<player>.*?)\\)'
  },
  countdownEngage: {
    en: 'Engage!',
    de: 'Start!',
    fr: 'À l\'attaque[ ]?!',
    ja: '戦闘開始！',
    cn: '战斗开始！',
    ko: '전투 시작!'
  },
  countdownCancel: {
    en: 'Countdown canceled by (?<player>\\y{Name})',
    de: '(?<player>\\y{Name}) hat den Countdown abgebrochen',
    fr: 'Le compte à rebours a été interrompu par (?<player>\\y{Name})[ ]?\\.',
    ja: '(?<player>\\y{Name})により、戦闘開始カウントがキャンセルされました。',
    cn: '(?<player>\\y{Name})取消了战斗开始倒计时。',
    ko: '(?<player>\\y{Name}) 님이 초읽기를 취소했습니다\\.'
  },
  areaSeal: {
    en: '(?<area>.*?) will be sealed off in (?<time>\\y{Float}) seconds!',
    de: 'Noch (?<time>\\y{Float}) Sekunden, bis sich (?<area>.*?) schließt',
    fr: 'Fermeture (?<area>.*?) dans (?<time>\\y{Float}) secondes[ ]?\\.',
    ja: '(?<area>.*?)の封鎖まであと(?<time>\\y{Float})秒',
    cn: '距(?<area>.*?)被封锁还有(?<time>\\y{Float})秒',
    ko: '(?<time>\\y{Float})초 후에 (?<area>.*?)(이|가) 봉쇄됩니다\\.'
  },
  areaUnseal: {
    en: '(?<area>.*?) is no longer sealed.',
    de: '(?<area>.*?) öffnet sich erneut.',
    fr: 'Ouverture (?<area>.*?)[ ]?!',
    ja: '(?<area>.*?)の封鎖が解かれた……',
    cn: '(?<area>.*?)的封锁解除了',
    ko: '(?<area>.*?)의 봉쇄가 해제되었습니다\\.'
  },
  // Recipe name always start with \ue0bb
  // HQ icon is \ue03c
  craftingStart: {
    en: 'You begin synthesizing (?<count>(an?|\\d+) )?\ue0bb(?<recipe>.*)\\.',
    de: 'Du hast begonnen, durch Synthese (?<count>(ein(e|es|em|er)?|\\d+) )?\ue0bb(?<recipe>.*) herzustellen\\.',
    fr: 'Vous commencez à fabriquer (?<count>(une?|\\d+) )?\ue0bb(?<recipe>.*)\\.',
    ja: '(?<player>\\y{Name})は\ue0bb(?<recipe>.*)(×(?<count>\\d+))?の製作を開始した。',
    cn: '(?<player>\\y{Name})开始制作“\ue0bb(?<recipe>.*)”(×(?<count>\\d+))?。',
    ko: '\ue0bb(?<recipe>.*)(×(?<count>\\d+)개)? 제작을 시작합니다\\.'
  },
  trialCraftingStart: {
    en: 'You begin trial synthesis of \ue0bb(?<recipe>.*)\\.',
    de: 'Du hast mit der Testsynthese von \ue0bb(?<recipe>.*) begonnen\\.',
    fr: 'Vous commencez une synthèse d\'essai pour une? \ue0bb(?<recipe>.*)\\.',
    ja: '(?<player>\\y{Name})は\ue0bb(?<recipe>.*)の製作練習を開始した。',
    cn: '(?<player>\\y{Name})开始练习制作\ue0bb(?<recipe>.*)。',
    ko: '\ue0bb(?<recipe>.*) 제작 연습을 시작합니다\\.'
  },
  craftingFinish: {
    en: 'You synthesize (?<count>(an?|\\d+) )?\ue0bb(?<recipe>.*)(\ue03c)?\\.',
    de: 'Du hast erfolgreich (?<count>(ein(e|es|em|er)?|\\d+) )?(?<recipe>.*)(\ue03c)? hergestellt\\.',
    fr: 'Vous fabriquez (?<count>(une?|\\d+) )?\ue0bb(?<recipe>.*)(\ue03c)?\\.',
    ja: '(?<player>\\y{Name})は\ue0bb(?<recipe>.*)(\ue03c)?(×(?<count>\\d+))?を完成させた！',
    cn: '(?<player>\\y{Name})制作“\ue0bb(?<recipe>.*)(\ue03c)?”(×(?<count>\\d+))?成功！',
    ko: '(?<player>\\y{Name}) 님이 \ue0bb(?<recipe>.*)(\ue03c)?(×(?<count>\\d+)개)?(을|를) 완성했습니다!'
  },
  trialCraftingFinish: {
    en: 'Your trial synthesis of \ue0bb(?<recipe>.*) proved a success!',
    de: 'Die Testsynthese von \ue0bb(?<recipe>.*) war erfolgreich!',
    fr: 'Votre synthèse d\'essai pour fabriquer \ue0bb(?<recipe>.*) a été couronnée de succès!',
    ja: '(?<player>\\y{Name})は\ue0bb(?<recipe>.*)の製作練習に成功した！',
    cn: '(?<player>\\y{Name})练习制作\ue0bb(?<recipe>.*)成功了！',
    ko: '\ue0bb(?<recipe>.*) 제작 연습에 성공했습니다!'
  },
  craftingFail: {
    en: 'Your synthesis fails!',
    de: 'Deine Synthese ist fehlgeschlagen!',
    fr: 'La synthèse échoue\\.{3}',
    ja: '(?<player>\\y{Name})は製作に失敗した……',
    cn: '(?<player>\\y{Name})制作失败了……',
    ko: '제작에 실패했습니다……\\.'
  },
  trialCraftingFail: {
    en: 'Your trial synthesis of \ue0bb(?<recipe>.*) failed\\.{3}',
    de: 'Die Testsynthese von \ue0bb(?<recipe>.*) ist fehlgeschlagen\\.{3}',
    fr: 'Votre synthèse d\'essai pour fabriquer \ue0bb(?<recipe>.*) s\'est soldée par un échec\\.{3}',
    ja: '(?<player>\\y{Name})は\ue0bb(?<recipe>.*)の製作練習に失敗した……',
    cn: '(?<player>\\y{Name})练习制作\ue0bb(?<recipe>.*)失败了……',
    ko: '\ue0bb(?<recipe>.*) 제작 연습에 실패했습니다……\\.'
  },
  craftingCancel: {
    en: 'You cancel the synthesis\\.',
    de: 'Du hast die Synthese abgebrochen\\.',
    fr: 'La synthèse est annulée\\.',
    ja: '(?<player>\\y{Name})は製作を中止した。',
    cn: '(?<player>\\y{Name})中止了制作作业。',
    ko: '제작을 중지했습니다\\.'
  },
  trialCraftingCancel: {
    en: 'You abandoned trial synthesis\\.',
    de: 'Testsynthese abgebrochen\\.',
    fr: 'Vous avez interrompu la synthèse d\'essai\\.',
    ja: '(?<player>\\y{Name})は製作練習を中止した。',
    cn: '(?<player>\\y{Name})停止了练习。',
    ko: '제작 연습을 중지했습니다\\.'
  }
};
class RegexSet {
  get localeRegex() {
    if (this.regexes) return this.regexes;
    this.regexes = this.buildLocaleRegexes(localeLines, s => regexes_Regexes.gameLog({
      line: `${s}.*?`
    }));
    return this.regexes;
  }
  get localeNetRegex() {
    if (this.netRegexes) return this.netRegexes;
    this.netRegexes = this.buildLocaleRegexes(localeLines, s => NetRegexes.gameLog({
      line: `${s}[^|]*?`
    }));
    return this.netRegexes;
  }
  buildLocaleRegexes(locales, builder) {
    return Object.fromEntries(Object.entries(locales).map(([key, lines]) => [key, this.buildLocaleRegex(lines, builder)]));
  }
  buildLocaleRegex(lines, builder) {
    const regexEn = builder(lines.en);
    return {
      en: regexEn,
      de: lines.de !== undefined ? builder(lines.de) : regexEn,
      fr: lines.fr !== undefined ? builder(lines.fr) : regexEn,
      ja: lines.ja !== undefined ? builder(lines.ja) : regexEn,
      cn: lines.cn !== undefined ? builder(lines.cn) : regexEn,
      ko: lines.ko !== undefined ? builder(lines.ko) : regexEn
    };
  }
}
const regexSet = new RegexSet();
const LocaleRegex = regexSet.localeRegex;
const LocaleNetRegex = regexSet.localeNetRegex;

// Translate a trigger or timeline regex (replaceSync) or timeline text (replaceText),
// returning the text and whether or not it can be considered "translated".
// Note, this won't catch anything that needs multiple translations, but will catch
// anything from common translations that are partial (e.g. a seal regex needs
// a zone name to be considered a full translation.
const translateWithReplacements = (text, replaceKey, replaceLang, replacements) => {
  // Special cases for empty and "not empty".
  if (text === '' || text === '[^:]+' || text === '[^|]+') return {
    text: text,
    wasTranslated: true
  };

  // All regex replacements are always global.
  const isGlobal = replaceKey === 'replaceSync';
  let wasTranslated = false;
  for (const r of replacements ?? []) {
    if (r.locale && r.locale !== replaceLang) continue;
    const reps = r[replaceKey];
    if (!reps) continue;
    for (const [key, value] of Object.entries(reps)) {
      const regex = isGlobal ? Regexes.parseGlobal(key) : Regexes.parse(key);
      if (text.match(regex)) wasTranslated = true;
      text = text.replace(regex, value);
    }
  }

  // Common Replacements
  const replacement = commonReplacement[replaceKey];
  for (const [key, value] of Object.entries(replacement ?? {})) {
    const repl = value[replaceLang];
    if (repl === undefined) continue;
    const regex = isGlobal ? Regexes.parseGlobal(key) : Regexes.parse(key);
    const partialKeys = replaceKey === 'replaceSync' ? partialCommonTriggerReplacementKeys : partialCommonTimelineReplacementKeys;
    if (text.match(regex)) {
      // Consider any partial translations as "not found" (e.g. a seal
      // message that still needs the zone name to be translated to be
      // considered fully translated).
      let isPartial = false;
      for (const partialKey of partialKeys) {
        if (Regexes.parseGlobal(partialKey).test(key)) {
          isPartial = true;
          break;
        }
      }
      if (!isPartial) wasTranslated = true;
    }
    text = text.replace(regex, repl);
  }
  return {
    text,
    wasTranslated
  };
};

// Translates a timeline or trigger regex for a given language.
const translateRegex = (text, replaceLang, replacements) => {
  if (typeof text === 'string') return translateWithReplacements(text, 'replaceSync', replaceLang, replacements).text;
  return translateWithReplacements(text.source, 'replaceSync', replaceLang, replacements).text;
};

// Translates a timeline text for a given language.
const translateText = (text, replaceLang, replacements) => translateWithReplacements(text, 'replaceText', replaceLang, replacements).text;
const translateRegexBuildParam = (params, replaceLang, replacements) => {
  return translateRegexBuildParamAnon(params, replaceLang, replacements);
};
const translateRegexBuildParamAnon = (anonParams, replaceLang, replacements) => {
  let missingFields = undefined;
  let wasTranslated = true;

  // TODO: it's probably ok that this isn't a deep copy because we don't
  // modify string[] directly, but it probably should be anyway.
  const params = {
    ...anonParams
  };
  for (const key of keysThatRequireTranslation) {
    const value = anonParams[key];
    if (typeof value === 'boolean' || value === undefined) continue;
    // TODO: ideally, it'd be nice to assign directly back to params[key] instead of
    // cheating and assigning back through anonParams.  The reason this is mostly
    // ok is that if params[key] is a string it only gets assigned a string,
    // and if it is a string[] it only gets assigned a string[], so the type can't
    // change.  It might be possible to assign to params[key] if we make
    // timestamp a string | string[]?
    if (typeof value === 'string') {
      const result = translateWithReplacements(value, 'replaceSync', replaceLang, replacements);
      params[key] = result.text;
      wasTranslated = wasTranslated && result.wasTranslated;
      if (!result.wasTranslated) (missingFields ??= []).push(key);
    } else {
      params[key] = value.map(x => {
        if (typeof x !== 'string') return x;
        const result = translateWithReplacements(x, 'replaceSync', replaceLang, replacements);
        wasTranslated = wasTranslated && result.wasTranslated;
        if (!result.wasTranslated) (missingFields ??= []).push(key);
        return result.text;
      });
    }
  }
  return {
    params,
    wasTranslated,
    missingFields
  };
};
;// CONCATENATED MODULE: ./ui/raidboss/emulator/EmulatorCommon.ts




// Disable no-explicit-any for cloneData as it needs to work on raw objects for performance reasons.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const querySelectorSafe = (node, sel) => {
  const ret = node.querySelector(sel);
  if (!(ret instanceof HTMLElement)) throw new UnreachableCode();
  return ret;
};
const querySelectorAllSafe = (node, sel) => {
  const ret = [...node.querySelectorAll(sel)].map(elem => {
    if (!(elem instanceof HTMLElement)) throw new UnreachableCode();
    return elem;
  });
  return ret;
};
const getTemplateChild = (node, sel) => {
  const template = querySelectorSafe(node, sel);
  if (!(template instanceof HTMLTemplateElement)) throw new UnreachableCode();
  const ret = template.content.firstElementChild;
  if (!ret) throw new UnreachableCode();
  if (!(ret instanceof HTMLElement)) throw new UnreachableCode();
  return ret;
};
const cloneSafe = node => {
  const cloned = node.cloneNode(true);
  if (!(cloned instanceof HTMLElement)) throw new UnreachableCode();
  return cloned;
};
class EmulatorCommon {
  static cloneData(data, exclude = ['options', 'party']) {
    const ret = {};

    // Use extra logic for top-level extend for property exclusion
    // This cut the execution time of this code from 41,000ms to 50ms when parsing a 12 minute pull
    for (const i in data) {
      if (exclude.includes(i)) continue;
      if (typeof data[i] === 'object') {
        // Cloning any. See DataType definition above for reasoning.
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        ret[i] = EmulatorCommon._cloneData(data[i]);
        continue;
      }

      // Assignment of any to any. See DataType definition above for reasoning.
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      ret[i] = data[i];
    }
    return ret;
  }
  static _cloneData(data) {
    if (typeof data === 'object') {
      if (Array.isArray(data)) {
        const ret = [];
        for (let i = 0; i < data.length; ++i) {
          // Cloning any. See DataType definition above for reasoning.
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          ret[i] = EmulatorCommon._cloneData(data[i]);
        }
        return ret;
      }
      if (data === null) return null;
      if (data instanceof RegExp) return new RegExp(data);
      const ret = {};
      for (const i in data) {
        // Cloning any. See DataType definition above for reasoning.
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        ret[i] = EmulatorCommon._cloneData(data[i]);
      }
      return ret;
    }
    return data;
  }
  static doesLineMatch(line, regexes) {
    if (regexes instanceof RegExp) return regexes.exec(line);
    for (const langStr in regexes) {
      const lang = langStr;
      const res = regexes[lang].exec(line);
      if (res) {
        if (res.groups) res.groups.language = lang;
        return res;
      }
    }
    return null;
  }
  static matchStart(line) {
    let res;
    // Currently all of these regexes have groups if they match at all,
    // but be robust to that changing in the future.
    res = EmulatorCommon.doesLineMatch(line, EmulatorCommon.countdownRegexes);
    if (res) {
      return {
        StartIn: (parseInt(res.groups?.time ?? '0') * 1000).toString(),
        StartType: 'Countdown',
        language: res.groups?.language ?? undefined
      };
    }
    res = EmulatorCommon.doesLineMatch(line, EmulatorCommon.sealRegexes);
    if (res) {
      return {
        StartIn: '0',
        StartType: 'Seal',
        language: res.groups?.language ?? undefined
      };
    }
    res = EmulatorCommon.doesLineMatch(line, EmulatorCommon.engageRegexes);
    if (res) {
      return {
        StartIn: '0',
        StartType: 'Engage',
        language: res.groups?.language ?? undefined
      };
    }
  }
  static matchEnd(line) {
    let res;
    // Currently all of these regexes have groups if they match at all,
    // but be robust to that changing in the future.
    res = EmulatorCommon.doesLineMatch(line, EmulatorCommon.winRegex);
    if (res) {
      return {
        EndType: 'Win',
        language: res.groups?.language ?? undefined
      };
    }
    res = EmulatorCommon.doesLineMatch(line, EmulatorCommon.wipeRegex);
    if (res) {
      return {
        EndType: 'Wipe',
        language: res.groups?.language ?? undefined
      };
    }
    res = EmulatorCommon.doesLineMatch(line, EmulatorCommon.cactbotWipeRegex);
    if (res) {
      return {
        EndType: 'Cactbot Wipe',
        language: res.groups?.language ?? undefined
      };
    }
    res = EmulatorCommon.doesLineMatch(line, EmulatorCommon.unsealRegexes);
    if (res) {
      return {
        EndType: 'Unseal',
        language: res.groups?.language ?? undefined
      };
    }
  }
  static sealRegexes = LocaleNetRegex.areaSeal;
  static engageRegexes = LocaleNetRegex.countdownEngage;
  static countdownRegexes = LocaleNetRegex.countdownStart;
  static unsealRegexes = LocaleNetRegex.areaUnseal;
  static wipeRegex = commonNetRegex.wipe;
  static winRegex = NetRegexes.network6d({
    command: '4000000[23]'
  });
  static cactbotWipeRegex = NetRegexes.echo({
    line: 'cactbot wipe.*?'
  });
}
;// CONCATENATED MODULE: ./resources/outputs.ts
// Output strings for now require a field for every language, so this is a
// helper function to generate one for literal numbers.
const numberToOutputString = function (n) {
  const str = n.toString();
  return {
    en: str,
    de: str,
    fr: str,
    ja: str,
    cn: str,
    ko: str
  };
};

// General guidelines:
// * property names should closely match English text
// * use OnPlayer suffix for things with `${player}`
// * use OnTarget suffix for things with `${name}`
// * any other parameters (of which there are none, currently) should use consistent suffixes.
// * the value of each property should be a single object with localized keys
/* harmony default export */ const outputs = ({
  aoe: {
    en: 'aoe',
    de: 'AoE',
    fr: 'AoE',
    ja: '全体攻撃',
    cn: 'AoE',
    ko: '전체 공격'
  },
  bigAoe: {
    en: 'big aoe!',
    de: 'Große AoE!',
    fr: 'Grosse AoE !',
    ja: '強力な全体攻撃',
    cn: '大AoE伤害！',
    ko: '강한 전체 공격!'
  },
  bleedAoe: {
    en: 'AoE + Bleed',
    de: 'AoE + Blutung',
    fr: 'AoE + Saignement',
    ja: '全体攻撃 + DoT',
    cn: 'AOE + 流血',
    ko: '전체 공격 + 도트'
  },
  tankBuster: {
    en: 'Tank Buster',
    de: 'Tank buster',
    fr: 'Tank buster',
    ja: 'タンク強攻撃',
    cn: '坦克死刑',
    ko: '탱버'
  },
  miniBuster: {
    en: 'Mini Buster',
    de: 'Kleiner Tankbuster',
    fr: 'Mini Buster',
    ja: 'タンク攻撃',
    cn: '小死刑',
    ko: '약한 탱버'
  },
  tankBusterOnPlayer: {
    en: 'Tank Buster on ${player}',
    de: 'Tank buster auf ${player}',
    fr: 'Tank buster sur ${player}',
    ja: '${player}に強攻撃',
    cn: '死刑 点 ${player}',
    ko: '"${player}" 탱버'
  },
  tankBusterOnYou: {
    en: 'Tank Buster on YOU',
    de: 'Tank buster auf DIR',
    fr: 'Tank buster sur VOUS',
    ja: '自分に強攻撃',
    cn: '死刑点名',
    ko: '탱버 대상자'
  },
  // when there are multiple tankbusters going out
  tankBusters: {
    en: 'Tank Busters',
    de: 'Tank busters',
    fr: 'Tank busters',
    ja: 'タンク強攻撃',
    cn: '坦克死刑',
    ko: '탱버'
  },
  tankCleave: {
    en: 'Tank cleave',
    de: 'Tank Cleave',
    fr: 'Tank cleave',
    ja: 'タンク範囲攻撃',
    cn: '顺劈',
    ko: '광역 탱버'
  },
  tankBusterCleaves: {
    en: 'Tank Buster Cleaves',
    de: 'Tankbuster Cleaves',
    fr: 'Tankbuster cleaves',
    ja: 'MT・ST同時範囲攻撃',
    cn: '双T扇形死刑',
    ko: '동시 광역 탱버'
  },
  tankBusterCleavesOnYou: {
    en: 'Tank Cleaves on YOU',
    de: 'Tank Cleaves auf DIR',
    fr: 'Tank cleaves sur VOUS',
    ja: 'MT・ST同時範囲攻撃(自分対象)',
    cn: '坦克顺劈点名',
    ko: '광역 탱버 대상자'
  },
  avoidTankCleave: {
    en: 'Avoid tank cleave',
    de: 'Tank Cleave ausweichen',
    fr: 'Évitez le tank cleave',
    ja: 'タンク範囲攻撃を避ける',
    cn: '远离顺劈',
    ko: '광역 탱버 피하기'
  },
  avoidTankCleaves: {
    en: 'Avoid Tank Cleaves',
    de: 'Tankbuster Cleaves ausweichen',
    fr: 'Évitez les cleaves (tankbusters)',
    ja: '範囲攻撃を避けて',
    cn: '躲避双T扇形死刑',
    ko: '광역 탱버 피하기'
  },
  tankCleaveOnYou: {
    en: 'Tank cleave on YOU',
    de: 'Tank Cleave aud DIR',
    fr: 'Tank cleave sur VOUS',
    ja: '自分に範囲攻撃',
    cn: '顺劈点名',
    ko: '나에게 광역 탱버'
  },
  sharedTankbuster: {
    en: 'Shared Tank Buster',
    de: 'Geteilter Tankbuster',
    fr: 'Partagez le Tank buster',
    ja: 'タンク頭割り',
    cn: '分摊死刑',
    ko: '쉐어 탱버'
  },
  sharedTankbusterOnYou: {
    en: 'Shared Tank Buster on YOU',
    de: 'geteilter Tankbuster auf DIR',
    fr: 'Tank buster à partager sur VOUS',
    ja: '自分にタンク頭割り',
    cn: '分摊死刑点名',
    ko: '쉐어 탱버 대상자'
  },
  sharedTankbusterOnPlayer: {
    en: 'Shared Tank Buster on ${player}',
    de: 'geteilter Tankbuster on ${player}',
    fr: 'Tank buster à partager sur ${player}',
    ja: '${player} にタンク頭割り',
    cn: '分摊死刑点 ${player}',
    ko: '"${player}" 쉐어 탱버'
  },
  tankSwap: {
    en: 'Tank Swap!',
    de: 'Tankwechsel!',
    fr: 'Tank swap !',
    ja: 'タンクスイッチ!',
    cn: '换T！',
    ko: '탱 교대'
  },
  spread: {
    en: 'Spread',
    de: 'Verteilen',
    fr: 'Dispersez-vous',
    ja: '散開',
    cn: '分散',
    ko: '산개'
  },
  stackMarker: {
    // for stack marker situations
    en: 'Stack',
    de: 'Sammeln',
    fr: 'Packez-vous',
    ja: '頭割り',
    cn: '分摊',
    ko: '쉐어뎀'
  },
  getTogether: {
    // for getting together without stack marker
    en: 'Stack',
    de: 'Sammeln',
    fr: 'Packez-vous',
    ja: '集合',
    cn: '集合',
    ko: '모이기'
  },
  healerGroups: {
    en: 'Healer Groups',
    de: 'Heiler-Gruppen',
    fr: 'Groupes sur les heals',
    ja: 'ヒラに頭割り',
    cn: '治疗分摊组',
    ko: '힐러 그룹 쉐어'
  },
  stackOnYou: {
    en: 'Stack on YOU',
    de: 'Auf DIR sammeln',
    fr: 'Package sur VOUS',
    ja: '自分に頭割り',
    cn: '集合点名',
    ko: '쉐어징 대상자'
  },
  stackOnPlayer: {
    en: 'Stack on ${player}',
    de: 'Auf ${player} sammeln',
    fr: 'Packez-vous sur ${player}',
    ja: '${player}に頭割り',
    cn: '靠近 ${player}集合',
    ko: '"${player}" 쉐어징'
  },
  stackMiddle: {
    en: 'Stack in middle',
    de: 'In der Mitte sammeln',
    fr: 'Packez-vous au milieu',
    ja: '中央で頭割り',
    cn: '中间集合',
    ko: '중앙에서 모이기'
  },
  doritoStack: {
    en: 'Dorito Stack',
    de: 'Mit Marker sammeln',
    fr: 'Packez les marques',
    ja: 'マーカー同士で頭割り',
    cn: '点名集合',
    ko: '징끼리 모이기'
  },
  spreadThenStack: {
    en: 'Spread => Stack',
    de: 'Verteilen => Sammeln',
    fr: 'Dispersion => Package',
    ja: '散開 => 頭割り',
    cn: '分散 => 集合',
    ko: '산개 => 집합'
  },
  stackThenSpread: {
    en: 'Stack => Spread',
    de: 'Sammeln => Verteilen',
    fr: 'Package => Dispersion',
    ja: '頭割り => 散開',
    cn: '集合 => 分散',
    ko: '집합 => 산개'
  },
  drawIn: {
    // Opposite of a knockback.
    en: 'Draw In',
    de: 'Einzug',
    fr: 'Attraction',
    ja: '吸込み',
    cn: '吸引',
    ko: '끌어당김'
  },
  knockback: {
    en: 'Knockback',
    de: 'Rückstoß',
    fr: 'Poussée',
    ja: 'ノックバック',
    cn: '击退',
    ko: '넉백'
  },
  knockbackOnYou: {
    en: 'Knockback on YOU',
    de: 'Rückstoß auf DIR',
    fr: 'Poussée sur VOUS',
    ja: '自分にノックバック',
    cn: '击退点名',
    ko: '넉백징 대상자'
  },
  knockbackOnPlayer: {
    en: 'Knockback on ${player}',
    de: 'Rückstoß auf ${player}',
    fr: 'Poussée sur ${player}',
    ja: '${player}にノックバック',
    cn: '击退点名${player}',
    ko: '"${player}" 넉백징'
  },
  lookTowardsBoss: {
    en: 'Look Towards Boss',
    de: 'Anschauen Boss',
    fr: 'Regardez le boss',
    ja: 'ボスを見る',
    cn: '面向Boss',
    ko: '쳐다보기'
  },
  lookAway: {
    en: 'Look Away',
    de: 'Wegschauen',
    fr: 'Regardez ailleurs',
    ja: 'ボスを見ない',
    cn: '背对Boss',
    ko: '뒤돌기'
  },
  lookAwayFromPlayer: {
    en: 'Look Away from ${player}',
    de: 'Schau weg von ${player}',
    fr: 'Ne regardez pas ${player}',
    ja: '${player}を見ない',
    cn: '背对${player}',
    ko: '${player}에게서 뒤돌기'
  },
  lookAwayFromTarget: {
    en: 'Look Away from ${name}',
    de: 'Schau weg von ${name}',
    fr: 'Ne regardez pas ${name}',
    ja: '${name}を見ない',
    cn: '背对${name}',
    ko: '${name}에게서 뒤돌기'
  },
  getBehind: {
    en: 'Get Behind',
    de: 'Hinter ihn',
    fr: 'Passez derrière',
    ja: '背面へ',
    cn: '去背后',
    ko: '보스 뒤로'
  },
  goFrontOrSides: {
    en: 'Go Front / Sides',
    de: 'Gehe nach Vorne/ zu den Seiten',
    fr: 'Allez Devant / Côtés',
    ja: '前／横へ',
    cn: '去前侧方',
    ko: '보스 후방 피하기'
  },
  goFront: {
    en: 'Go Front',
    de: 'Geh nach vorn',
    fr: 'Allez Devant',
    ja: '前へ',
    cn: '去前面',
    ko: '앞으로'
  },
  // getUnder is used when you have to get into the bosses hitbox
  getUnder: {
    en: 'Get Under',
    de: 'Unter ihn',
    fr: 'En dessous',
    ja: 'ボスに貼り付く',
    cn: '去脚下',
    ko: '보스 아래로'
  },
  // in is more like "get close but maybe even melee range is fine"
  in: {
    en: 'In',
    de: 'Rein',
    fr: 'Intérieur',
    ja: '中へ',
    cn: '靠近',
    ko: '안으로'
  },
  // out means get far away
  out: {
    en: 'Out',
    de: 'Raus',
    fr: 'Extérieur',
    ja: '外へ',
    cn: '远离',
    ko: '밖으로'
  },
  outOfMelee: {
    en: 'Out of melee',
    de: 'Raus aus Nahkampf',
    fr: 'Sortez de la mêlée',
    ja: '近接の範囲から離れる',
    cn: '离开近战距离',
    ko: '근접범위 밖으로'
  },
  inThenOut: {
    en: 'In => out',
    de: 'Rein, dann raus',
    fr: 'Intérieur, puis extérieur',
    ja: '中 => 外',
    cn: '先靠近，再远离',
    ko: '안으로 => 밖으로'
  },
  outThenIn: {
    en: 'Out => in',
    de: 'Raus, dann rein',
    fr: 'Extérieur, puis intérieur',
    ja: '外 => 中',
    cn: '先远离，再靠近',
    ko: '밖으로 => 안으로'
  },
  backThenFront: {
    en: 'Back => Front',
    de: 'Nach Hinten, danach nach Vorne',
    fr: 'Derrière puis devant',
    ja: '後ろ => 前',
    cn: '后 => 前',
    ko: '뒤로 => 앞으로'
  },
  frontThenBack: {
    en: 'Front => Back',
    de: 'Nach Vorne, danach nach Hinten',
    fr: 'Devant puis derrière',
    ja: '前 => 後ろ',
    cn: '前 => 后',
    ko: '앞으로 => 뒤로'
  },
  goIntoMiddle: {
    en: 'Get Middle',
    de: 'in die Mitte gehen',
    fr: 'Allez au milieu',
    ja: '中へ',
    cn: '去中间',
    ko: '중앙으로'
  },
  front: {
    en: 'Front',
    de: 'Vorne',
    fr: 'Devant',
    ja: '前',
    cn: '前',
    ko: '앞'
  },
  back: {
    en: 'Back',
    de: 'Hinten',
    fr: 'Derrière',
    ja: '後ろ',
    cn: '后',
    ko: '뒤'
  },
  right: {
    en: 'Right',
    de: 'Rechts',
    fr: 'À droite',
    ja: '右へ',
    cn: '右',
    ko: '오른쪽'
  },
  left: {
    en: 'Left',
    de: 'Links',
    fr: 'À gauche',
    ja: '左へ',
    cn: '左',
    ko: '왼쪽'
  },
  getLeftAndWest: {
    en: '<= Get Left/West',
    de: '<= Nach Links/Westen',
    fr: '<= Allez à Gauche/Ouest',
    ja: '<= 左/西へ',
    cn: '<= 去左/西边',
    ko: '<= 왼쪽으로'
  },
  getRightAndEast: {
    en: 'Get Right/East =>',
    de: 'Nach Rechts/Osten =>',
    fr: 'Allez à Droite/Est =>',
    ja: '右/東へ =>',
    cn: '去右/东边 =>',
    ko: '오른쪽으로 =>'
  },
  leftThenRight: {
    en: 'Left => Right',
    de: 'Links => Rechts',
    fr: 'À gauche => À droite',
    ja: '左 => 右',
    cn: '左 => 右',
    ko: '왼쪽 => 오른쪽'
  },
  rightThenLeft: {
    en: 'Right => Left',
    de: 'Rechts => Links',
    fr: 'À droite => À gauche',
    ja: '右 => 左',
    cn: '右 => 左',
    ko: '오른쪽 => 왼쪽'
  },
  goFrontBack: {
    en: 'Go Front/Back',
    de: 'Geh nach Vorne/Hinten',
    fr: 'Allez Devant/Derrière',
    ja: '縦へ',
    cn: '去前后',
    ko: '앞/뒤로'
  },
  sides: {
    en: 'Sides',
    de: 'Seiten',
    fr: 'Côtés',
    ja: '横へ',
    cn: '去侧面',
    ko: '양옆으로'
  },
  middle: {
    en: 'Middle',
    de: 'Mitte',
    fr: 'Milieu',
    ja: '中へ',
    cn: '中间',
    ko: '중앙'
  },
  clockwise: {
    en: 'Clockwise',
    de: 'Im Uhrzeigersinn',
    fr: 'Sens horaire',
    ja: '時針回り',
    cn: '顺时针',
    ko: '시계방향'
  },
  counterclockwise: {
    en: 'Counter-clock',
    de: 'Gegen den Uhrzeigersinn',
    fr: 'Anti-horaire',
    ja: '反時針回り',
    cn: '逆时针',
    ko: '반시계방향'
  },
  // killAdds is used for adds that will always be available
  killAdds: {
    en: 'Kill adds',
    de: 'Adds besiegen',
    fr: 'Tuez les adds',
    ja: '雑魚から倒して',
    cn: '击杀小怪',
    ko: '쫄 잡기'
  },
  // killExtraAdd is used for adds that appear if a mechanic was not played correctly
  killExtraAdd: {
    en: 'Kill Extra Add',
    de: 'Add besiegen',
    fr: 'Tuez l\'add',
    ja: '雑魚から倒して',
    cn: '击杀小怪',
    ko: '쫄 잡기'
  },
  awayFromFront: {
    en: 'Away From Front',
    de: 'Weg von Vorne',
    fr: 'Éloignez-vous du devant',
    ja: '前方から離れる',
    cn: '远离正面',
    ko: '보스 전방 피하기'
  },
  sleepTarget: {
    en: 'Sleep ${name}',
    de: 'Schlaf auf ${name}',
    fr: 'Sommeil sur ${name}',
    ja: '${name} にスリプル',
    cn: '催眠 ${name}',
    ko: '${name} 슬리플'
  },
  stunTarget: {
    en: 'Stun ${name}',
    de: 'Betäubung auf ${name}',
    fr: 'Étourdissez ${name}',
    ja: '${name} にスタン',
    cn: '眩晕 ${name}',
    ko: '${name}기절'
  },
  interruptTarget: {
    en: 'interrupt ${name}',
    de: 'unterbreche ${name}',
    fr: 'Interrompez ${name}',
    ja: '${name} に沈黙',
    cn: '打断${name}',
    ko: '${name}기술 시전 끊기'
  },
  preyOnYou: {
    en: 'Prey on YOU',
    de: 'Marker auf DIR',
    fr: 'Marquage sur VOUS',
    ja: '自分に捕食',
    cn: '掠食点名',
    ko: '홍옥징 대상자'
  },
  preyOnPlayer: {
    en: 'Prey on ${player}',
    de: 'Marker auf ${player}',
    fr: 'Marquage sur ${player}',
    ja: '${player}に捕食',
    cn: '掠食点名${player}',
    ko: '"${player}" 홍옥징'
  },
  awayFromGroup: {
    en: 'Away from Group',
    de: 'Weg von der Gruppe',
    fr: 'Éloignez-vous du groupe',
    ja: '外へ',
    cn: '远离人群',
    ko: '다른 사람들과 떨어지기'
  },
  awayFromPlayer: {
    en: 'Away from ${player}',
    de: 'Weg von ${player}',
    fr: 'Éloignez-vous de ${player}',
    ja: '${player}から離れる',
    cn: '远离${player}',
    ko: '"${player}"에게서 멀어지기'
  },
  meteorOnYou: {
    en: 'Meteor on YOU',
    de: 'Meteor auf DIR',
    fr: 'Météore sur VOUS',
    ja: '自分にメテオ',
    cn: '陨石点名',
    ko: '나에게 메테오징'
  },
  stopMoving: {
    en: 'Stop Moving!',
    de: 'Bewegung stoppen!',
    fr: 'Ne bougez pas !',
    ja: '移動禁止！',
    cn: '停止移动！',
    ko: '이동 멈추기!'
  },
  stopEverything: {
    en: 'Stop Everything!',
    de: 'Stoppe Alles!',
    fr: 'Arrêtez tout !',
    ja: '行動禁止！',
    cn: '停止行动！',
    ko: '행동 멈추기!'
  },
  moveAway: {
    // move away to dodge aoes
    en: 'Move!',
    de: 'Bewegen!',
    fr: 'Bougez !',
    ja: '避けて！',
    cn: '快躲开！',
    ko: '이동하기!'
  },
  moveAround: {
    // move around (e.g. jumping) to avoid being frozen
    en: 'Move!',
    de: 'Bewegen!',
    fr: 'Bougez !',
    ja: '動く！',
    cn: '快动！',
    ko: '움직이기!'
  },
  breakChains: {
    en: 'Break chains',
    de: 'Kette zerbrechen',
    fr: 'Brisez les chaines',
    ja: '線を切る',
    cn: '切断连线',
    ko: '선 끊기'
  },
  moveChainsTogether: {
    en: 'Move chains together',
    de: 'Ketten zusammen bewegen',
    fr: 'Bougez les chaines ensemble',
    ja: '線同士で一緒に移動',
    cn: '连线一起移动',
    ko: '선 붙어서 같이 움직이기'
  },
  earthshakerOnYou: {
    en: 'Earth Shaker on YOU',
    de: 'Erdstoß auf DIR',
    fr: 'Marque de terre sur VOUS',
    ja: '自分にアースシェイカー',
    cn: '大地摇动点名',
    ko: '어스징 대상자'
  },
  wakeUp: {
    en: 'WAKE UP',
    de: 'AUFWACHEN',
    fr: 'RÉVEILLE-TOI',
    ja: '目を覚まして！',
    cn: '醒醒！动一动！！',
    ko: '일어나세요!'
  },
  closeTethersWithPlayer: {
    en: 'Close Tethers (${player})',
    de: 'Nahe Verbindungen (${player})',
    fr: 'Liens proches avec (${player})',
    ja: '${player}に近づく',
    cn: '靠近连线 (${player})',
    ko: '상대와 가까이 붙기 (${player})'
  },
  farTethersWithPlayer: {
    en: 'Far Tethers (${player})',
    de: 'Entfernte Verbindungen (${player})',
    fr: 'Liens éloignés avec (${player})',
    ja: ' (${player})から離れる',
    cn: '远离连线 (${player})',
    ko: '상대와 떨어지기 (${player})'
  },
  getTowers: {
    en: 'Get Towers',
    de: 'Türme nehmen',
    fr: 'Allez dans les tours',
    ja: '塔を踏む',
    cn: '踩塔',
    ko: '기둥 들어가기'
  },
  unknown: {
    en: '???',
    de: '???',
    fr: '???',
    ja: '???',
    cn: '???',
    ko: '???'
  },
  north: {
    en: 'North',
    de: 'Norden',
    fr: 'Nord',
    ja: '北',
    cn: '上(北)',
    ko: '북쪽'
  },
  south: {
    en: 'South',
    de: 'Süden',
    fr: 'Sud',
    ja: '南',
    cn: '下(南)',
    ko: '남쪽'
  },
  east: {
    en: 'East',
    de: 'Osten',
    fr: 'Est',
    ja: '東',
    cn: '右(东)',
    ko: '동쪽'
  },
  west: {
    en: 'West',
    de: 'Westen',
    fr: 'Ouest',
    ja: '西',
    cn: '左(西)',
    ko: '서쪽'
  },
  northwest: {
    en: 'Northwest',
    de: 'Nordwesten',
    fr: 'Nord-Ouest',
    ja: '北西',
    cn: '左上(西北)',
    ko: '북서쪽'
  },
  northeast: {
    en: 'Northeast',
    de: 'Nordosten',
    fr: 'Nord-Est',
    ja: '北東',
    cn: '右上(东北)',
    ko: '북동쪽'
  },
  southwest: {
    en: 'Southwest',
    de: 'Südwesten',
    fr: 'Sud-Ouest',
    ja: '南西',
    cn: '左下(西南)',
    ko: '남서쪽'
  },
  southeast: {
    en: 'Southeast',
    de: 'Südosten',
    fr: 'Sud-Est',
    ja: '南東',
    cn: '右下(东南)',
    ko: '남동쪽'
  },
  dirN: {
    en: 'N',
    de: 'N',
    fr: 'N',
    ja: '北',
    cn: '上(北)',
    ko: '북'
  },
  dirS: {
    en: 'S',
    de: 'S',
    fr: 'S',
    ja: '南',
    cn: '下(南)',
    ko: '남'
  },
  dirE: {
    en: 'E',
    de: 'O',
    fr: 'E',
    ja: '東',
    cn: '右(东)',
    ko: '동'
  },
  dirW: {
    en: 'W',
    de: 'W',
    fr: 'O',
    ja: '西',
    cn: '左(西)',
    ko: '서'
  },
  dirNW: {
    en: 'NW',
    de: 'NW',
    fr: 'NO',
    ja: '北西',
    cn: '左上(西北)',
    ko: '북서'
  },
  dirNE: {
    en: 'NE',
    de: 'NO',
    fr: 'NE',
    ja: '北東',
    cn: '右上(东北)',
    ko: '북동'
  },
  dirSW: {
    en: 'SW',
    de: 'SW',
    fr: 'SO',
    ja: '南西',
    cn: '左下(西南)',
    ko: '남서'
  },
  dirSE: {
    en: 'SE',
    de: 'SO',
    fr: 'SE',
    ja: '南東',
    cn: '右下(东南)',
    ko: '남동'
  },
  dirNNE: {
    en: 'NNE',
    de: 'NNO',
    fr: 'NNE',
    ja: '北北東(1時)',
    cn: '上偏右(北偏东)',
    ko: '1시'
  },
  dirENE: {
    en: 'ENE',
    de: 'ONO',
    fr: 'ENE',
    ja: '東北東(2時)',
    cn: '右偏上(东偏北)',
    ko: '2시'
  },
  dirESE: {
    en: 'ESE',
    de: 'OSO',
    fr: 'ESE',
    ja: '東南東(4時)',
    cn: '右偏下(东偏南)',
    ko: '4시'
  },
  dirSSE: {
    en: 'SSE',
    de: 'SSO',
    fr: 'SSE',
    ja: '南南東(5時)',
    cn: '下偏右(南偏东)',
    ko: '5시'
  },
  dirSSW: {
    en: 'SSW',
    de: 'SSW',
    fr: 'SSO',
    ja: '南南西(7時)',
    cn: '下偏左(南偏西)',
    ko: '7시'
  },
  dirWSW: {
    en: 'WSW',
    de: 'WSW',
    fr: 'OSO',
    ja: '西南西(8時)',
    cn: '左偏下(西偏南)',
    ko: '8시'
  },
  dirWNW: {
    en: 'WNW',
    de: 'WNW',
    fr: 'ONO',
    ja: '西北西(10時)',
    cn: '左偏上(西偏北)',
    ko: '10시'
  },
  dirNNW: {
    en: 'NNW',
    de: 'NNW',
    fr: 'NNO',
    ja: '北北西(11時)',
    cn: '上偏左(北偏西)',
    ko: '11시'
  },
  tank: {
    en: 'Tank',
    de: 'Tank',
    fr: 'Tank',
    ja: 'タンク',
    cn: '坦克',
    ko: '탱'
  },
  healer: {
    en: 'Healer',
    de: 'Heiler',
    fr: 'Healer',
    ja: 'ヒーラー',
    cn: '治疗',
    ko: '힐'
  },
  dps: {
    en: 'DPS',
    de: 'DPS',
    fr: 'DPS',
    ja: 'DPS',
    cn: 'DPS',
    ko: '딜러'
  },
  // Literal numbers.
  num0: numberToOutputString(0),
  num1: numberToOutputString(1),
  num2: numberToOutputString(2),
  num3: numberToOutputString(3),
  num4: numberToOutputString(4),
  num5: numberToOutputString(5),
  num6: numberToOutputString(6),
  num7: numberToOutputString(7),
  num8: numberToOutputString(8),
  num9: numberToOutputString(9)
});
;// CONCATENATED MODULE: ./resources/overlay_plugin_api.ts
// OverlayPlugin API setup

let inited = false;
let wsUrl = null;
let ws = null;
let queue = [];
let rseqCounter = 0;
const responsePromises = {};
const subscribers = {};
const sendMessage = (msg, cb) => {
  if (ws) {
    if (queue) queue.push(msg);else ws.send(JSON.stringify(msg));
  } else {
    if (queue) queue.push([msg, cb]);else window.OverlayPluginApi.callHandler(JSON.stringify(msg), cb);
  }
};
const processEvent = msg => {
  init();
  const subs = subscribers[msg.type];
  subs?.forEach(sub => {
    try {
      sub(msg);
    } catch (e) {
      console.error(e);
    }
  });
};
const dispatchOverlayEvent = processEvent;
const addOverlayListener = (event, cb) => {
  init();
  if (!subscribers[event]) {
    subscribers[event] = [];
    if (!queue) {
      sendMessage({
        call: 'subscribe',
        events: [event]
      });
    }
  }
  subscribers[event]?.push(cb);
};
const removeOverlayListener = (event, cb) => {
  init();
  if (subscribers[event]) {
    const list = subscribers[event];
    const pos = list?.indexOf(cb);
    if (pos !== undefined && pos > -1) list?.splice(pos, 1);
  }
};
const callOverlayHandlerInternal = (_msg
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) => {
  init();
  const msg = {
    ..._msg,
    rseq: 0
  };
  let p;
  if (ws) {
    msg.rseq = rseqCounter++;
    p = new Promise((resolve, reject) => {
      responsePromises[msg.rseq] = {
        resolve: resolve,
        reject: reject
      };
    });
    sendMessage(msg);
  } else {
    p = new Promise((resolve, reject) => {
      sendMessage(msg, data => {
        if (data === null) {
          resolve(data);
          return;
        }
        const parsed = JSON.parse(data);
        if (parsed['$error']) reject(parsed);else resolve(parsed);
      });
    });
  }
  return p;
};
const callOverlayHandlerOverrideMap = {};
const callOverlayHandler = (_msg
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) => {
  init();

  // If this `as` is incorrect, then it will not find an override.
  // TODO: we could also replace this with a type guard.
  const type = _msg.call;
  const callFunc = callOverlayHandlerOverrideMap[type] ?? callOverlayHandlerInternal;

  // The `IOverlayHandler` type guarantees that parameters/return type match
  // one of the overlay handlers.  The OverrideMap also only stores functions
  // that match by the discriminating `call` field, and so any overrides
  // should be correct here.
  // eslint-disable-next-line max-len
  // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-argument
  return callFunc(_msg);
};
const setOverlayHandlerOverride = (type, override) => {
  if (!override) {
    delete callOverlayHandlerOverrideMap[type];
    return;
  }
  callOverlayHandlerOverrideMap[type] = override;
};
const init = () => {
  if (inited) return;
  if (typeof window !== 'undefined') {
    wsUrl = new URLSearchParams(window.location.search).get('OVERLAY_WS');
    if (wsUrl !== null) {
      const connectWs = function (wsUrl) {
        ws = new WebSocket(wsUrl);
        ws.addEventListener('error', e => {
          console.error(e);
        });
        ws.addEventListener('open', () => {
          console.log('Connected!');
          const q = queue ?? [];
          queue = null;
          sendMessage({
            call: 'subscribe',
            events: Object.keys(subscribers)
          });
          for (const msg of q) {
            if (!Array.isArray(msg)) sendMessage(msg);
          }
        });
        ws.addEventListener('message', _msg => {
          try {
            if (typeof _msg.data !== 'string') {
              console.error('Invalid message data received: ', _msg);
              return;
            }
            const msg = JSON.parse(_msg.data);
            const promiseFuncs = msg?.rseq !== undefined ? responsePromises[msg.rseq] : undefined;
            if (msg.rseq !== undefined && promiseFuncs) {
              if (msg['$error']) promiseFuncs.reject(msg);else promiseFuncs.resolve(msg);
              delete responsePromises[msg.rseq];
            } else {
              processEvent(msg);
            }
          } catch (e) {
            console.error('Invalid message received: ', _msg);
            return;
          }
        });
        ws.addEventListener('close', () => {
          queue = null;
          console.log('Trying to reconnect...');
          // Don't spam the server with retries.
          window.setTimeout(() => {
            connectWs(wsUrl);
          }, 300);
        });
      };
      connectWs(wsUrl);
    } else {
      const waitForApi = function () {
        if (!window.OverlayPluginApi?.ready) {
          window.setTimeout(waitForApi, 300);
          return;
        }
        const q = queue ?? [];
        queue = null;
        window.__OverlayCallback = processEvent;
        sendMessage({
          call: 'subscribe',
          events: Object.keys(subscribers)
        });
        for (const item of q) {
          if (Array.isArray(item)) sendMessage(item[0], item[1]);
        }
      };
      waitForApi();
    }

    // Here the OverlayPlugin API is registered to the window object,
    // but this is mainly for backwards compatibility. For cactbot's built-in files,
    // it is recommended to use the various functions exported in resources/overlay_plugin_api.ts.

    /* eslint-disable deprecation/deprecation */
    window.addOverlayListener = addOverlayListener;
    window.removeOverlayListener = removeOverlayListener;
    window.callOverlayHandler = callOverlayHandler;
    window.dispatchOverlayEvent = dispatchOverlayEvent;
    /* eslint-enable deprecation/deprecation */
  }

  inited = true;
};
;// CONCATENATED MODULE: ./resources/util.ts




// TODO: it'd be nice to not repeat job names, but at least Record enforces that all are set.
const nameToJobEnum = {
  NONE: 0,
  GLA: 1,
  PGL: 2,
  MRD: 3,
  LNC: 4,
  ARC: 5,
  CNJ: 6,
  THM: 7,
  CRP: 8,
  BSM: 9,
  ARM: 10,
  GSM: 11,
  LTW: 12,
  WVR: 13,
  ALC: 14,
  CUL: 15,
  MIN: 16,
  BTN: 17,
  FSH: 18,
  PLD: 19,
  MNK: 20,
  WAR: 21,
  DRG: 22,
  BRD: 23,
  WHM: 24,
  BLM: 25,
  ACN: 26,
  SMN: 27,
  SCH: 28,
  ROG: 29,
  NIN: 30,
  MCH: 31,
  DRK: 32,
  AST: 33,
  SAM: 34,
  RDM: 35,
  BLU: 36,
  GNB: 37,
  DNC: 38,
  RPR: 39,
  SGE: 40
};
const allJobs = Object.keys(nameToJobEnum);
const allRoles = ['tank', 'healer', 'dps', 'crafter', 'gatherer', 'none'];
const tankJobs = ['GLA', 'PLD', 'MRD', 'WAR', 'DRK', 'GNB'];
const healerJobs = ['CNJ', 'WHM', 'SCH', 'AST', 'SGE'];
const meleeDpsJobs = ['PGL', 'MNK', 'LNC', 'DRG', 'ROG', 'NIN', 'SAM', 'RPR'];
const rangedDpsJobs = ['ARC', 'BRD', 'DNC', 'MCH'];
const casterDpsJobs = ['BLU', 'RDM', 'BLM', 'SMN', 'ACN', 'THM'];
const dpsJobs = [...meleeDpsJobs, ...rangedDpsJobs, ...casterDpsJobs];
const craftingJobs = ['CRP', 'BSM', 'ARM', 'GSM', 'LTW', 'WVR', 'ALC', 'CUL'];
const gatheringJobs = ['MIN', 'BTN', 'FSH'];
const stunJobs = ['BLU', ...tankJobs, ...meleeDpsJobs];
const silenceJobs = ['BLU', ...tankJobs, ...rangedDpsJobs];
const sleepJobs = [...casterDpsJobs, ...healerJobs];
const feintJobs = [...meleeDpsJobs];
const addleJobs = [...casterDpsJobs];
const cleanseJobs = ['BLU', 'BRD', ...healerJobs];
const jobToRoleMap = (() => {
  const addToMap = (map, jobs, role) => {
    jobs.forEach(job => map.set(job, role));
  };
  const map = new Map([['NONE', 'none']]);
  addToMap(map, tankJobs, 'tank');
  addToMap(map, healerJobs, 'healer');
  addToMap(map, dpsJobs, 'dps');
  addToMap(map, craftingJobs, 'crafter');
  addToMap(map, gatheringJobs, 'gatherer');
  return map;
})();
const watchCombatantMap = [];
const shouldCancelWatch = (params, entry) => {
  if (entry.cancel) return true;
  if (params.maxDuration !== undefined && Date.now() - entry.start > params.maxDuration) return true;
  return false;
};
const defaultWatchCombatant = (params, func) => {
  return new Promise((res, rej) => {
    const delay = params.delay ?? 1000;
    const call = {
      call: 'getCombatants'
    };
    if (params.ids) call.ids = params.ids;
    if (params.names) call.names = params.names;
    if (params.props) call.props = params.props;
    const entry = {
      cancel: false,
      start: Date.now()
    };
    watchCombatantMap.push(entry);
    const checkFunc = () => {
      if (shouldCancelWatch(params, entry)) {
        rej(new Error('cancelled'));
        return;
      }
      void callOverlayHandler(call).then(response => {
        if (entry.cancel) {
          rej(new Error('was cancelled'));
          return;
        }
        if (func(response)) res();else window.setTimeout(checkFunc, delay);
      });
    };
    window.setTimeout(checkFunc, delay);
  });
};
let watchCombatantOverride;
let clearCombatantsOverride;
const defaultClearCombatants = () => {
  while (watchCombatantMap.length > 0) {
    const watch = watchCombatantMap.pop();
    if (watch) watch.cancel = true;
  }
};
const watchCombatant = (params, func) => {
  if (watchCombatantOverride) return watchCombatantOverride(params, func);
  return defaultWatchCombatant(params, func);
};
const output8Dir = ['dirN', 'dirNE', 'dirE', 'dirSE', 'dirS', 'dirSW', 'dirW', 'dirNW'];
const output16Dir = ['dirN', 'dirNNE', 'dirNE', 'dirENE', 'dirE', 'dirESE', 'dirSE', 'dirSSE', 'dirS', 'dirSSW', 'dirSW', 'dirWSW', 'dirW', 'dirWNW', 'dirNW', 'dirNNW'];
const outputCardinalDir = ['dirN', 'dirE', 'dirS', 'dirW'];
const outputIntercardDir = ['dirNE', 'dirSE', 'dirSW', 'dirNW'];
const outputStrings16Dir = {
  dirN: outputs.dirN,
  dirNNE: outputs.dirNNE,
  dirNE: outputs.dirNE,
  dirENE: outputs.dirENE,
  dirE: outputs.dirE,
  dirESE: outputs.dirESE,
  dirSE: outputs.dirSE,
  dirSSE: outputs.dirSSE,
  dirS: outputs.dirS,
  dirSSW: outputs.dirSSW,
  dirSW: outputs.dirSW,
  dirWSW: outputs.dirWSW,
  dirW: outputs.dirW,
  dirWNW: outputs.dirWNW,
  dirNW: outputs.dirNW,
  dirNNW: outputs.dirNNW,
  unknown: outputs.unknown
};
const outputStrings8Dir = {
  dirN: outputs.dirN,
  dirNE: outputs.dirNE,
  dirE: outputs.dirE,
  dirSE: outputs.dirSE,
  dirS: outputs.dirS,
  dirSW: outputs.dirSW,
  dirW: outputs.dirW,
  dirNW: outputs.dirNW,
  unknown: outputs.unknown
};
const outputStringsCardinalDir = {
  dirN: outputs.dirN,
  dirE: outputs.dirE,
  dirS: outputs.dirS,
  dirW: outputs.dirW,
  unknown: outputs.unknown
};
const outputStringsIntercardDir = {
  dirNE: outputs.dirNE,
  dirSE: outputs.dirSE,
  dirSW: outputs.dirSW,
  dirNW: outputs.dirNW,
  unknown: outputs.unknown
};

// TODO: Accept 'north' as a function input and adjust output accordingly.
// E.g. Math.round((north + 4) - 4 * Math.atan2(x, y) / Math.PI) % 8;
// Will need to adjust the output arrays as well though.

const xyTo16DirNum = (x, y, centerX, centerY) => {
  // N = 0, NNE = 1, ..., NNW = 15
  x = x - centerX;
  y = y - centerY;
  return Math.round(8 - 8 * Math.atan2(x, y) / Math.PI) % 16;
};
const xyTo8DirNum = (x, y, centerX, centerY) => {
  // N = 0, NE = 1, ..., NW = 7
  x = x - centerX;
  y = y - centerY;
  return Math.round(4 - 4 * Math.atan2(x, y) / Math.PI) % 8;
};
const xyTo4DirNum = (x, y, centerX, centerY) => {
  // N = 0, E = 1, S = 2, W = 3
  x = x - centerX;
  y = y - centerY;
  return Math.round(2 - 2 * Math.atan2(x, y) / Math.PI) % 4;
};
const hdgTo8DirNum = heading => {
  // N = 0, NE = 1, ..., NW = 7
  return (Math.round(4 - 4 * heading / Math.PI) % 8 + 8) % 8;
};
const hdgTo4DirNum = heading => {
  // N = 0, E = 1, S = 2, W = 3
  return (Math.round(2 - heading * 2 / Math.PI) % 4 + 4) % 4;
};
const outputFrom8DirNum = dirNum => {
  return output8Dir[dirNum] ?? 'unknown';
};
const outputFromCardinalNum = dirNum => {
  return outputCardinalDir[dirNum] ?? 'unknown';
};
const Directions = {
  output8Dir: output8Dir,
  output16Dir: output16Dir,
  outputCardinalDir: outputCardinalDir,
  outputIntercardDir: outputIntercardDir,
  outputStrings16Dir: outputStrings16Dir,
  outputStrings8Dir: outputStrings8Dir,
  outputStringsCardinalDir: outputStringsCardinalDir,
  outputStringsIntercardDir: outputStringsIntercardDir,
  xyTo16DirNum: xyTo16DirNum,
  xyTo8DirNum: xyTo8DirNum,
  xyTo4DirNum: xyTo4DirNum,
  hdgTo8DirNum: hdgTo8DirNum,
  hdgTo4DirNum: hdgTo4DirNum,
  outputFrom8DirNum: outputFrom8DirNum,
  combatantStatePosTo8Dir: (combatant, centerX, centerY) => {
    return xyTo8DirNum(combatant.PosX, combatant.PosY, centerX, centerY);
  },
  combatantStatePosTo8DirOutput: (combatant, centerX, centerY) => {
    const dirNum = xyTo8DirNum(combatant.PosX, combatant.PosY, centerX, centerY);
    return outputFrom8DirNum(dirNum);
  },
  combatantStateHdgTo8Dir: combatant => {
    return hdgTo8DirNum(combatant.Heading);
  },
  combatantStateHdgTo8DirOutput: combatant => {
    const dirNum = hdgTo8DirNum(combatant.Heading);
    return outputFrom8DirNum(dirNum);
  },
  addedCombatantPosTo8Dir: (combatant, centerX, centerY) => {
    const x = parseFloat(combatant.x);
    const y = parseFloat(combatant.y);
    return xyTo8DirNum(x, y, centerX, centerY);
  },
  addedCombatantPosTo8DirOutput: (combatant, centerX, centerY) => {
    const x = parseFloat(combatant.x);
    const y = parseFloat(combatant.y);
    const dirNum = xyTo8DirNum(x, y, centerX, centerY);
    return outputFrom8DirNum(dirNum);
  },
  addedCombatantHdgTo8Dir: combatant => {
    const heading = parseFloat(combatant.heading);
    return hdgTo8DirNum(heading);
  },
  addedCombatantHdgTo8DirOutput: combatant => {
    const heading = parseFloat(combatant.heading);
    const dirNum = hdgTo8DirNum(heading);
    return outputFrom8DirNum(dirNum);
  },
  xyTo8DirOutput: (x, y, centerX, centerY) => {
    const dirNum = xyTo8DirNum(x, y, centerX, centerY);
    return outputFrom8DirNum(dirNum);
  },
  xyToCardinalDirOutput: (x, y, centerX, centerY) => {
    const dirNum = xyTo4DirNum(x, y, centerX, centerY);
    return outputFromCardinalNum(dirNum);
  }
};
const Util = {
  jobEnumToJob: id => {
    const job = allJobs.find(job => nameToJobEnum[job] === id);
    return job ?? 'NONE';
  },
  jobToJobEnum: job => nameToJobEnum[job],
  jobToRole: job => {
    const role = jobToRoleMap.get(job);
    return role ?? 'none';
  },
  getAllRoles: () => allRoles,
  isTankJob: job => tankJobs.includes(job),
  isHealerJob: job => healerJobs.includes(job),
  isMeleeDpsJob: job => meleeDpsJobs.includes(job),
  isRangedDpsJob: job => rangedDpsJobs.includes(job),
  isCasterDpsJob: job => casterDpsJobs.includes(job),
  isDpsJob: job => dpsJobs.includes(job),
  isCraftingJob: job => craftingJobs.includes(job),
  isGatheringJob: job => gatheringJobs.includes(job),
  isCombatJob: job => {
    return !craftingJobs.includes(job) && !gatheringJobs.includes(job);
  },
  canStun: job => stunJobs.includes(job),
  canSilence: job => silenceJobs.includes(job),
  canSleep: job => sleepJobs.includes(job),
  canCleanse: job => cleanseJobs.includes(job),
  canFeint: job => feintJobs.includes(job),
  canAddle: job => addleJobs.includes(job),
  watchCombatant: watchCombatant,
  clearWatchCombatants: () => {
    if (clearCombatantsOverride !== undefined) clearCombatantsOverride();else defaultClearCombatants();
  },
  setWatchCombatantOverride: (watchFunc, clearFunc) => {
    watchCombatantOverride = watchFunc;
    clearCombatantsOverride = clearFunc;
  },
  gameLogCodes: gameLogCodes,
  shortName: (name, playerNicks) => {
    // TODO: make this unique among the party in case of first name collisions.
    if (typeof name !== 'string') {
      if (typeof name !== 'undefined') console.error('called ShortNamify with non-string');
      return '???';
    }
    const nick = playerNicks[name];
    if (nick !== undefined) return nick;
    const idx = name.indexOf(' ');
    return idx < 0 ? name : name.slice(0, idx);
  }
};
/* harmony default export */ const util = (Util);
;// CONCATENATED MODULE: ./resources/world_id.ts
// Auto-generated from gen_world_ids.ts
// DO NOT EDIT THIS FILE DIRECTLY

// NOTE: This data is filtered to public worlds only (i.e. isPublic: true)

const worldNameToWorld = name => {
  return Object.values(world_id_data).find(world => {
    if (world.name === name) {
      return true;
    }
  });
};
const world_id_data = {
  '21': {
    'dataCenter': {
      'id': 9,
      'name': 'Materia'
    },
    'id': 21,
    'internalName': 'Ravana',
    'name': 'Ravana',
    'region': 1,
    'userType': 7
  },
  '22': {
    'dataCenter': {
      'id': 9,
      'name': 'Materia'
    },
    'id': 22,
    'internalName': 'Bismarck',
    'name': 'Bismarck',
    'region': 1,
    'userType': 7
  },
  '23': {
    'dataCenter': {
      'id': 3,
      'name': 'Mana'
    },
    'id': 23,
    'internalName': 'Asura',
    'name': 'Asura',
    'region': 1,
    'userType': 1
  },
  '24': {
    'dataCenter': {
      'id': 10,
      'name': 'Meteor'
    },
    'id': 24,
    'internalName': 'Belias',
    'name': 'Belias',
    'region': 1,
    'userType': 1
  },
  '28': {
    'dataCenter': {
      'id': 3,
      'name': 'Mana'
    },
    'id': 28,
    'internalName': 'Pandaemonium',
    'name': 'Pandaemonium',
    'region': 1,
    'userType': 1
  },
  '29': {
    'dataCenter': {
      'id': 10,
      'name': 'Meteor'
    },
    'id': 29,
    'internalName': 'Shinryu',
    'name': 'Shinryu',
    'region': 1,
    'userType': 1
  },
  '30': {
    'dataCenter': {
      'id': 10,
      'name': 'Meteor'
    },
    'id': 30,
    'internalName': 'Unicorn',
    'name': 'Unicorn',
    'region': 1,
    'userType': 1
  },
  '31': {
    'dataCenter': {
      'id': 10,
      'name': 'Meteor'
    },
    'id': 31,
    'internalName': 'Yojimbo',
    'name': 'Yojimbo',
    'region': 1,
    'userType': 1
  },
  '32': {
    'dataCenter': {
      'id': 10,
      'name': 'Meteor'
    },
    'id': 32,
    'internalName': 'Zeromus',
    'name': 'Zeromus',
    'region': 1,
    'userType': 1
  },
  '33': {
    'dataCenter': {
      'id': 7,
      'name': 'Light'
    },
    'id': 33,
    'internalName': 'Twintania',
    'name': 'Twintania',
    'region': 1,
    'userType': 5
  },
  '34': {
    'dataCenter': {
      'id': 8,
      'name': 'Crystal'
    },
    'id': 34,
    'internalName': 'Brynhildr',
    'name': 'Brynhildr',
    'region': 1,
    'userType': 3
  },
  '35': {
    'dataCenter': {
      'id': 5,
      'name': 'Primal'
    },
    'id': 35,
    'internalName': 'Famfrit',
    'name': 'Famfrit',
    'region': 1,
    'userType': 3
  },
  '36': {
    'dataCenter': {
      'id': 7,
      'name': 'Light'
    },
    'id': 36,
    'internalName': 'Lich',
    'name': 'Lich',
    'region': 1,
    'userType': 5
  },
  '37': {
    'dataCenter': {
      'id': 8,
      'name': 'Crystal'
    },
    'id': 37,
    'internalName': 'Mateus',
    'name': 'Mateus',
    'region': 1,
    'userType': 3
  },
  '38': {
    'id': 38,
    'internalName': 'Shemhazai',
    'name': 'Shemhazai',
    'region': 1,
    'userType': 3
  },
  '39': {
    'dataCenter': {
      'id': 6,
      'name': 'Chaos'
    },
    'id': 39,
    'internalName': 'Omega',
    'name': 'Omega',
    'region': 1,
    'userType': 5
  },
  '40': {
    'dataCenter': {
      'id': 4,
      'name': 'Aether'
    },
    'id': 40,
    'internalName': 'Jenova',
    'name': 'Jenova',
    'region': 1,
    'userType': 3
  },
  '41': {
    'dataCenter': {
      'id': 8,
      'name': 'Crystal'
    },
    'id': 41,
    'internalName': 'Zalera',
    'name': 'Zalera',
    'region': 1,
    'userType': 3
  },
  '42': {
    'dataCenter': {
      'id': 7,
      'name': 'Light'
    },
    'id': 42,
    'internalName': 'Zodiark',
    'name': 'Zodiark',
    'region': 1,
    'userType': 5
  },
  '43': {
    'dataCenter': {
      'id': 2,
      'name': 'Gaia'
    },
    'id': 43,
    'internalName': 'Alexander',
    'name': 'Alexander',
    'region': 1,
    'userType': 1
  },
  '44': {
    'dataCenter': {
      'id': 3,
      'name': 'Mana'
    },
    'id': 44,
    'internalName': 'Anima',
    'name': 'Anima',
    'region': 1,
    'userType': 1
  },
  '45': {
    'dataCenter': {
      'id': 1,
      'name': 'Elemental'
    },
    'id': 45,
    'internalName': 'Carbuncle',
    'name': 'Carbuncle',
    'region': 1,
    'userType': 1
  },
  '46': {
    'dataCenter': {
      'id': 2,
      'name': 'Gaia'
    },
    'id': 46,
    'internalName': 'Fenrir',
    'name': 'Fenrir',
    'region': 1,
    'userType': 1
  },
  '47': {
    'dataCenter': {
      'id': 3,
      'name': 'Mana'
    },
    'id': 47,
    'internalName': 'Hades',
    'name': 'Hades',
    'region': 1,
    'userType': 1
  },
  '48': {
    'dataCenter': {
      'id': 3,
      'name': 'Mana'
    },
    'id': 48,
    'internalName': 'Ixion',
    'name': 'Ixion',
    'region': 1,
    'userType': 1
  },
  '49': {
    'dataCenter': {
      'id': 1,
      'name': 'Elemental'
    },
    'id': 49,
    'internalName': 'Kujata',
    'name': 'Kujata',
    'region': 1,
    'userType': 1
  },
  '50': {
    'dataCenter': {
      'id': 1,
      'name': 'Elemental'
    },
    'id': 50,
    'internalName': 'Typhon',
    'name': 'Typhon',
    'region': 1,
    'userType': 1
  },
  '51': {
    'dataCenter': {
      'id': 2,
      'name': 'Gaia'
    },
    'id': 51,
    'internalName': 'Ultima',
    'name': 'Ultima',
    'region': 1,
    'userType': 1
  },
  '52': {
    'dataCenter': {
      'id': 10,
      'name': 'Meteor'
    },
    'id': 52,
    'internalName': 'Valefor',
    'name': 'Valefor',
    'region': 1,
    'userType': 1
  },
  '53': {
    'dataCenter': {
      'id': 5,
      'name': 'Primal'
    },
    'id': 53,
    'internalName': 'Exodus',
    'name': 'Exodus',
    'region': 1,
    'userType': 3
  },
  '54': {
    'dataCenter': {
      'id': 4,
      'name': 'Aether'
    },
    'id': 54,
    'internalName': 'Faerie',
    'name': 'Faerie',
    'region': 1,
    'userType': 3
  },
  '55': {
    'dataCenter': {
      'id': 5,
      'name': 'Primal'
    },
    'id': 55,
    'internalName': 'Lamia',
    'name': 'Lamia',
    'region': 1,
    'userType': 3
  },
  '56': {
    'dataCenter': {
      'id': 7,
      'name': 'Light'
    },
    'id': 56,
    'internalName': 'Phoenix',
    'name': 'Phoenix',
    'region': 1,
    'userType': 5
  },
  '57': {
    'dataCenter': {
      'id': 4,
      'name': 'Aether'
    },
    'id': 57,
    'internalName': 'Siren',
    'name': 'Siren',
    'region': 1,
    'userType': 3
  },
  '58': {
    'dataCenter': {
      'id': 1,
      'name': 'Elemental'
    },
    'id': 58,
    'internalName': 'Garuda',
    'name': 'Garuda',
    'region': 1,
    'userType': 1
  },
  '59': {
    'dataCenter': {
      'id': 2,
      'name': 'Gaia'
    },
    'id': 59,
    'internalName': 'Ifrit',
    'name': 'Ifrit',
    'region': 1,
    'userType': 1
  },
  '60': {
    'dataCenter': {
      'id': 10,
      'name': 'Meteor'
    },
    'id': 60,
    'internalName': 'Ramuh',
    'name': 'Ramuh',
    'region': 1,
    'userType': 1
  },
  '61': {
    'dataCenter': {
      'id': 3,
      'name': 'Mana'
    },
    'id': 61,
    'internalName': 'Titan',
    'name': 'Titan',
    'region': 1,
    'userType': 1
  },
  '62': {
    'dataCenter': {
      'id': 8,
      'name': 'Crystal'
    },
    'id': 62,
    'internalName': 'Diabolos',
    'name': 'Diabolos',
    'region': 1,
    'userType': 3
  },
  '63': {
    'dataCenter': {
      'id': 4,
      'name': 'Aether'
    },
    'id': 63,
    'internalName': 'Gilgamesh',
    'name': 'Gilgamesh',
    'region': 1,
    'userType': 3
  },
  '64': {
    'dataCenter': {
      'id': 5,
      'name': 'Primal'
    },
    'id': 64,
    'internalName': 'Leviathan',
    'name': 'Leviathan',
    'region': 1,
    'userType': 3
  },
  '65': {
    'dataCenter': {
      'id': 4,
      'name': 'Aether'
    },
    'id': 65,
    'internalName': 'Midgardsormr',
    'name': 'Midgardsormr',
    'region': 1,
    'userType': 3
  },
  '66': {
    'dataCenter': {
      'id': 7,
      'name': 'Light'
    },
    'id': 66,
    'internalName': 'Odin',
    'name': 'Odin',
    'region': 1,
    'userType': 5
  },
  '67': {
    'dataCenter': {
      'id': 7,
      'name': 'Light'
    },
    'id': 67,
    'internalName': 'Shiva',
    'name': 'Shiva',
    'region': 1,
    'userType': 5
  },
  '68': {
    'dataCenter': {
      'id': 1,
      'name': 'Elemental'
    },
    'id': 68,
    'internalName': 'Atomos',
    'name': 'Atomos',
    'region': 1,
    'userType': 1
  },
  '69': {
    'dataCenter': {
      'id': 2,
      'name': 'Gaia'
    },
    'id': 69,
    'internalName': 'Bahamut',
    'name': 'Bahamut',
    'region': 1,
    'userType': 1
  },
  '70': {
    'dataCenter': {
      'id': 3,
      'name': 'Mana'
    },
    'id': 70,
    'internalName': 'Chocobo',
    'name': 'Chocobo',
    'region': 1,
    'userType': 1
  },
  '71': {
    'dataCenter': {
      'id': 6,
      'name': 'Chaos'
    },
    'id': 71,
    'internalName': 'Moogle',
    'name': 'Moogle',
    'region': 1,
    'userType': 5
  },
  '72': {
    'dataCenter': {
      'id': 1,
      'name': 'Elemental'
    },
    'id': 72,
    'internalName': 'Tonberry',
    'name': 'Tonberry',
    'region': 1,
    'userType': 1
  },
  '73': {
    'dataCenter': {
      'id': 4,
      'name': 'Aether'
    },
    'id': 73,
    'internalName': 'Adamantoise',
    'name': 'Adamantoise',
    'region': 1,
    'userType': 3
  },
  '74': {
    'dataCenter': {
      'id': 8,
      'name': 'Crystal'
    },
    'id': 74,
    'internalName': 'Coeurl',
    'name': 'Coeurl',
    'region': 1,
    'userType': 3
  },
  '75': {
    'dataCenter': {
      'id': 8,
      'name': 'Crystal'
    },
    'id': 75,
    'internalName': 'Malboro',
    'name': 'Malboro',
    'region': 1,
    'userType': 3
  },
  '76': {
    'dataCenter': {
      'id': 2,
      'name': 'Gaia'
    },
    'id': 76,
    'internalName': 'Tiamat',
    'name': 'Tiamat',
    'region': 1,
    'userType': 1
  },
  '77': {
    'dataCenter': {
      'id': 5,
      'name': 'Primal'
    },
    'id': 77,
    'internalName': 'Ultros',
    'name': 'Ultros',
    'region': 1,
    'userType': 3
  },
  '78': {
    'dataCenter': {
      'id': 5,
      'name': 'Primal'
    },
    'id': 78,
    'internalName': 'Behemoth',
    'name': 'Behemoth',
    'region': 1,
    'userType': 3
  },
  '79': {
    'dataCenter': {
      'id': 4,
      'name': 'Aether'
    },
    'id': 79,
    'internalName': 'Cactuar',
    'name': 'Cactuar',
    'region': 1,
    'userType': 3
  },
  '80': {
    'dataCenter': {
      'id': 6,
      'name': 'Chaos'
    },
    'id': 80,
    'internalName': 'Cerberus',
    'name': 'Cerberus',
    'region': 1,
    'userType': 5
  },
  '81': {
    'dataCenter': {
      'id': 8,
      'name': 'Crystal'
    },
    'id': 81,
    'internalName': 'Goblin',
    'name': 'Goblin',
    'region': 1,
    'userType': 3
  },
  '82': {
    'dataCenter': {
      'id': 10,
      'name': 'Meteor'
    },
    'id': 82,
    'internalName': 'Mandragora',
    'name': 'Mandragora',
    'region': 1,
    'userType': 1
  },
  '83': {
    'dataCenter': {
      'id': 6,
      'name': 'Chaos'
    },
    'id': 83,
    'internalName': 'Louisoix',
    'name': 'Louisoix',
    'region': 1,
    'userType': 5
  },
  '85': {
    'dataCenter': {
      'id': 6,
      'name': 'Chaos'
    },
    'id': 85,
    'internalName': 'Spriggan',
    'name': 'Spriggan',
    'region': 1,
    'userType': 5
  },
  '86': {
    'dataCenter': {
      'id': 9,
      'name': 'Materia'
    },
    'id': 86,
    'internalName': 'Sephirot',
    'name': 'Sephirot',
    'region': 1,
    'userType': 7
  },
  '87': {
    'dataCenter': {
      'id': 9,
      'name': 'Materia'
    },
    'id': 87,
    'internalName': 'Sophia',
    'name': 'Sophia',
    'region': 1,
    'userType': 7
  },
  '88': {
    'dataCenter': {
      'id': 9,
      'name': 'Materia'
    },
    'id': 88,
    'internalName': 'Zurvan',
    'name': 'Zurvan',
    'region': 1,
    'userType': 7
  },
  '90': {
    'dataCenter': {
      'id': 1,
      'name': 'Elemental'
    },
    'id': 90,
    'internalName': 'Aegis',
    'name': 'Aegis',
    'region': 1,
    'userType': 2
  },
  '91': {
    'dataCenter': {
      'id': 8,
      'name': 'Crystal'
    },
    'id': 91,
    'internalName': 'Balmung',
    'name': 'Balmung',
    'region': 1,
    'userType': 4
  },
  '92': {
    'dataCenter': {
      'id': 2,
      'name': 'Gaia'
    },
    'id': 92,
    'internalName': 'Durandal',
    'name': 'Durandal',
    'region': 1,
    'userType': 2
  },
  '93': {
    'dataCenter': {
      'id': 5,
      'name': 'Primal'
    },
    'id': 93,
    'internalName': 'Excalibur',
    'name': 'Excalibur',
    'region': 1,
    'userType': 4
  },
  '94': {
    'dataCenter': {
      'id': 1,
      'name': 'Elemental'
    },
    'id': 94,
    'internalName': 'Gungnir',
    'name': 'Gungnir',
    'region': 1,
    'userType': 2
  },
  '95': {
    'dataCenter': {
      'id': 5,
      'name': 'Primal'
    },
    'id': 95,
    'internalName': 'Hyperion',
    'name': 'Hyperion',
    'region': 1,
    'userType': 4
  },
  '96': {
    'dataCenter': {
      'id': 3,
      'name': 'Mana'
    },
    'id': 96,
    'internalName': 'Masamune',
    'name': 'Masamune',
    'region': 1,
    'userType': 2
  },
  '97': {
    'dataCenter': {
      'id': 6,
      'name': 'Chaos'
    },
    'id': 97,
    'internalName': 'Ragnarok',
    'name': 'Ragnarok',
    'region': 1,
    'userType': 6
  },
  '98': {
    'dataCenter': {
      'id': 2,
      'name': 'Gaia'
    },
    'id': 98,
    'internalName': 'Ridill',
    'name': 'Ridill',
    'region': 1,
    'userType': 2
  },
  '99': {
    'dataCenter': {
      'id': 4,
      'name': 'Aether'
    },
    'id': 99,
    'internalName': 'Sargatanas',
    'name': 'Sargatanas',
    'region': 1,
    'userType': 4
  },
  '400': {
    'dataCenter': {
      'id': 6,
      'name': 'Chaos'
    },
    'id': 400,
    'internalName': 'Sagittarius',
    'name': 'Sagittarius',
    'region': 1,
    'userType': 5
  },
  '401': {
    'dataCenter': {
      'id': 6,
      'name': 'Chaos'
    },
    'id': 401,
    'internalName': 'Phantom',
    'name': 'Phantom',
    'region': 1,
    'userType': 5
  },
  '402': {
    'dataCenter': {
      'id': 7,
      'name': 'Light'
    },
    'id': 402,
    'internalName': 'Alpha',
    'name': 'Alpha',
    'region': 1,
    'userType': 5
  },
  '403': {
    'dataCenter': {
      'id': 7,
      'name': 'Light'
    },
    'id': 403,
    'internalName': 'Raiden',
    'name': 'Raiden',
    'region': 1,
    'userType': 5
  },
  '404': {
    'dataCenter': {
      'id': 11,
      'name': 'Dynamis'
    },
    'id': 404,
    'internalName': 'Marilith',
    'name': 'Marilith',
    'region': 1,
    'userType': 3
  },
  '405': {
    'dataCenter': {
      'id': 11,
      'name': 'Dynamis'
    },
    'id': 405,
    'internalName': 'Seraph',
    'name': 'Seraph',
    'region': 1,
    'userType': 3
  },
  '406': {
    'dataCenter': {
      'id': 11,
      'name': 'Dynamis'
    },
    'id': 406,
    'internalName': 'Halicarnassus',
    'name': 'Halicarnassus',
    'region': 1,
    'userType': 3
  },
  '407': {
    'dataCenter': {
      'id': 11,
      'name': 'Dynamis'
    },
    'id': 407,
    'internalName': 'Maduin',
    'name': 'Maduin',
    'region': 1,
    'userType': 3
  },
  '3000': {
    'dataCenter': {
      'id': 12,
      'name': 'NA Cloud DC (Beta)'
    },
    'id': 3000,
    'internalName': 'Cloudtest01',
    'name': 'Cloudtest01',
    'region': 1,
    'userType': 9
  },
  '3001': {
    'dataCenter': {
      'id': 12,
      'name': 'NA Cloud DC (Beta)'
    },
    'id': 3001,
    'internalName': 'Cloudtest02',
    'name': 'Cloudtest02',
    'region': 1,
    'userType': 9
  }
};
/* harmony default export */ const world_id = ((/* unused pure expression or super */ null && (world_id_data)));
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/CombatantState.ts

class CombatantState {
  constructor(props, targetable) {
    Object.assign(this, props);

    // Force these values to something sane in case they're not in `props`
    this.CurrentHP ??= 0;
    this.MaxHP ??= 0;
    this.CurrentMP ??= 0;
    this.MaxMP ??= 0;
    this.PosX ??= 0;
    this.PosY ??= 0;
    this.PosZ ??= 0;
    this.Heading ??= 0;
    this.targetable = targetable;
  }
  partialClone(props) {
    return new CombatantState({
      ...this,
      ...props
    }, this.targetable);
  }
  fullClone() {
    return new CombatantState({
      ...this
    }, this.targetable);
  }
  setName(name) {
    // Sometimes network lines arrive after the combatant has been cleared
    // from memory in the client, so the network line will have a valid ID
    // but the name will be blank. Since we're tracking the name for the
    // entire fight and not on a state-by-state basis, we don't want to
    // blank out a name in this case.
    // If a combatant actually has a blank name, that's still allowed by
    // the constructor.
    if (name === '') return;
    const parts = name.split('(');
    this.Name = parts[0] ?? '';
    if (parts.length > 1) {
      const worldName = parts[1]?.replace(/\)$/, '');
      if (worldName !== undefined) {
        const world = worldNameToWorld(worldName);
        if (world !== undefined) this.WorldID = world.id;
      }
    }
  }
}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/Combatant.ts


class Combatant {
  tempStates = {};
  states = {};
  // State indexes are stored both in forward and reverse sequence
  // This prevents having to clone the array and reverse it every frame of playback,
  // or alternatively to have to loop through the array in reverse to find the target
  // timestamp. A slight increase in memory usage of 2-3kb to make the code
  // more readable.
  stateIndexes = [];
  reverseStateIndexes = [];
  get firstStateTimestamp() {
    const firstIndex = this.stateIndexes[0];
    if (firstIndex === undefined) throw new not_reached_UnreachableCode();
    return firstIndex;
  }
  get lastStateTimestamp() {
    const lastIndex = this.stateIndexes.slice(-1)[0];
    if (lastIndex === undefined) throw new not_reached_UnreachableCode();
    return lastIndex;
  }
  get firstState() {
    const firstStateIndex = this.firstStateTimestamp;
    return this.getState(firstStateIndex);
  }
  setState(state, timestamp) {
    return this.states[timestamp] = state;
  }
  hasState(timestamp) {
    return this.states[timestamp] !== undefined;
  }
  nextState(timestamp) {
    // If timestamp is a state already, return it
    if (this.stateIndexes.includes(timestamp)) return this.getState(timestamp);

    // Shortcut out if this timestamp is before the first or after the last timestamp
    if (timestamp < this.firstStateTimestamp) return this.getState(this.firstStateTimestamp);else if (timestamp > this.lastStateTimestamp) return this.getState(this.lastStateTimestamp);
    const stateTimestamp = this.stateIndexes.find(ts => ts > timestamp);
    if (stateTimestamp === undefined) throw new not_reached_UnreachableCode();
    return this.getState(stateTimestamp);
  }
  previousState(timestamp) {
    // If timestamp is a state already, return it
    if (this.stateIndexes.includes(timestamp)) return this.getState(timestamp);

    // Shortcut out if this timestamp is before the first or after the last timestamp
    if (timestamp < this.firstStateTimestamp) return this.getState(this.firstStateTimestamp);else if (timestamp > this.lastStateTimestamp) return this.getState(this.lastStateTimestamp);
    const stateTimestamp = this.reverseStateIndexes.find(ts => ts < timestamp);
    if (stateTimestamp === undefined) throw new not_reached_UnreachableCode();
    return this.getState(stateTimestamp);
  }
  getState(timestamp) {
    const stateByTimestamp = this.states[timestamp];
    if (stateByTimestamp) return stateByTimestamp;
    return this.previousState(timestamp);
  }
  getTempState(timestamp) {
    if (!this.tempStates) throw new Error('Invalid Combatant state');
    return this.tempStates[timestamp];
  }
  pushPartialState(timestamp, props) {
    if (!this.tempStates) throw new Error('Invalid Combatant state');
    if (this.tempStates[timestamp] === undefined) return this.tempStates[timestamp] = props;
    const state = this.tempStates[timestamp];
    if (!state) throw new not_reached_UnreachableCode();
    return this.tempStates[timestamp] = {
      ...state,
      ...props
    };
  }
  finalize() {
    if (!this.tempStates) throw new Error('Invalid Combatant state');
    const stateEntries = Object.entries(this.tempStates).sort((left, right) => left[0].localeCompare(right[0]));
    if (stateEntries.length < 1) return;
    const lastState = {
      key: parseInt(stateEntries[0]?.[0] ?? '0'),
      state: new CombatantState(stateEntries[0]?.[1] ?? {}, stateEntries[0]?.[1]?.targetable ?? false),
      json: JSON.stringify(stateEntries[0]?.[1])
    };
    this.states[lastState.key] = lastState.state;
    this.stateIndexes.push(lastState.key);
    for (const state of stateEntries.slice(1)) {
      const curKey = parseInt(state[0] ?? '0');
      let curState = lastState.state.partialClone(state[1]);
      const curJson = JSON.stringify(curState);
      if (curJson !== lastState.json) {
        lastState.state = curState;
      } else {
        // Re-use state to reduce memory usage
        curState = lastState.state;
      }
      this.states[curKey] = curState;
      this.stateIndexes.push(curKey);
    }
    this.reverseStateIndexes = [...this.stateIndexes].reverse();
    delete this.tempStates;
  }
}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/CombatantJobSearch.ts
class CombatantJobSearch {
  static getJob(abilityId) {
    for (const [key, value] of Object.entries(CombatantJobSearch.abilities)) {
      if (value?.includes(abilityId)) return key;
    }
  }
  static abilityMatchRegex = /[a-fA-F0-9]{1,4}/i;
  static abilities = {
    PLD: [12959, 12961, 12964, 12967, 12968, 12969, 12970, 12971, 12972, 12973, 12974, 12975, 12976, 12978, 12980, 12981, 12982, 12983, 12984, 12985, 12986, 12987, 12988, 12989, 12991, 12992, 12993, 12994, 12996, 13000, 13001, 13006, 14480, 16457, 16458, 16459, 16460, 16461, 17669, 17671, 17672, 17691, 17692, 17693, 17694, 17866, 18050, 27, 29, 30, 3538, 3539, 3540, 3541, 3542, 4284, 4285, 4286, 50207, 50209, 50246, 50260, 50261, 50262, 50263, 50264, 7382, 7383, 7384, 7385, 8746, 8749, 8750, 8751, 8752, 8754, 8755, 8756],
    WAR: [16462, 16463, 16464, 16465, 17695, 17696, 17697, 17698, 17889, 3549, 3550, 3551, 3552, 4289, 4290, 4291, 49, 50157, 50218, 50249, 50265, 50266, 50267, 50268, 50269, 51, 52, 7386, 7387, 7388, 7389, 8758, 8761, 8762, 8763, 8764, 8765, 8767, 8768],
    DRK: [16466, 16467, 16468, 16469, 16470, 16471, 16472, 17700, 17701, 17702, 3617, 3621, 3623, 3624, 3625, 3629, 3632, 3634, 3636, 3638, 3639, 3640, 3641, 3643, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4680, 50158, 50159, 50271, 50272, 50319, 7390, 7391, 7392, 7393, 8769, 8772, 8773, 8775, 8776, 8777, 8778, 8779],
    GNB: [17703, 17704, 17705, 17706, 17707, 17708, 17709, 17710, 17711, 17712, 17713, 17714, 17716, 17717, 17890, 17891, 16137, 50320, 16138, 16139, 16140, 16141, 16142, 16143, 16144, 16145, 16162, 50257, 16148, 16149, 16151, 16152, 50258, 16153, 16154, 16146, 16147, 16150, 16159, 16160, 16161, 16155, 16156, 16157, 16158, 16163, 16164, 16165, 50259],
    WHM: [12958, 12962, 12965, 12997, 13002, 13003, 13004, 13005, 131, 136, 137, 139, 140, 14481, 1584, 16531, 16532, 16533, 16534, 16535, 16536, 17688, 17689, 17690, 17789, 17790, 17791, 17793, 17794, 17832, 3568, 3569, 3570, 3571, 4296, 4297, 50181, 50182, 50196, 50307, 50308, 50309, 50310, 7430, 7431, 7432, 7433, 8895, 8896, 8900, 9621, 127, 133],
    SCH: [16537, 16538, 16539, 16540, 16541, 16542, 16543, 16544, 16545, 16546, 16547, 16548, 16550, 16551, 166, 167, 17215, 17216, 17795, 17796, 17797, 17798, 17802, 17864, 17865, 17869, 17870, 17990, 185, 186, 188, 189, 190, 3583, 3584, 3585, 3586, 3587, 4300, 50184, 50214, 50311, 50312, 50313, 50324, 7434, 7435, 7436, 7437, 7438, 7869, 802, 803, 805, 8904, 8905, 8909, 9622],
    AST: [10027, 10028, 10029, 16552, 16553, 16554, 16555, 16556, 16557, 16558, 16559, 17055, 17151, 17152, 17804, 17805, 17806, 17807, 17809, 17991, 3590, 3593, 3594, 3595, 3596, 3598, 3599, 3600, 3601, 3603, 3604, 3605, 3606, 3608, 3610, 3612, 3613, 3614, 3615, 4301, 4302, 4401, 4402, 4403, 4404, 4405, 4406, 4677, 4678, 4679, 50122, 50124, 50125, 50186, 50187, 50188, 50189, 50314, 50315, 50316, 7439, 7440, 7441, 7442, 7443, 7444, 7445, 7448, 8324, 8913, 8914, 8916, 9629],
    MNK: [12960, 12963, 12966, 12977, 12979, 12990, 12995, 12998, 12999, 14476, 14478, 16473, 16474, 16475, 16476, 17674, 17675, 17676, 17677, 17719, 17720, 17721, 17722, 17723, 17724, 17725, 17726, 3543, 3545, 3546, 3547, 4262, 4287, 4288, 50160, 50161, 50245, 50273, 50274, 63, 70, 71, 7394, 7395, 7396, 74, 8780, 8781, 8782, 8783, 8784, 8785, 8787, 8789, 8925],
    DRG: [16477, 16478, 16479, 16480, 17728, 17729, 3553, 3554, 3555, 3556, 3557, 4292, 4293, 50162, 50163, 50247, 50275, 50276, 7397, 7398, 7399, 7400, 86, 8791, 8792, 8793, 8794, 8795, 8796, 8797, 8798, 8799, 8802, 8803, 8804, 8805, 8806, 92, 94, 95, 96, 9640, 75, 78],
    NIN: [16488, 16489, 16491, 16492, 16493, 17413, 17414, 17415, 17416, 17417, 17418, 17419, 17420, 17732, 17733, 17734, 17735, 17736, 17737, 17738, 17739, 2246, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 3563, 3566, 4295, 50165, 50166, 50167, 50250, 50279, 50280, 7401, 7402, 7403, 8807, 8808, 8809, 8810, 8812, 8814, 8815, 8816, 8820, 9461],
    SAM: [16481, 16482, 16483, 16484, 16485, 16486, 16487, 17740, 17741, 17742, 17743, 17744, 50208, 50215, 50277, 50278, 7477, 7478, 7479, 7480, 7481, 7482, 7483, 7484, 7485, 7486, 7487, 7488, 7489, 7490, 7491, 7492, 7493, 7494, 7495, 7496, 7497, 7498, 7499, 7501, 7502, 7855, 7857, 7867, 8821, 8822, 8823, 8824, 8825, 8826, 8828, 8829, 8830, 8831, 8833],
    BRD: [10023, 114, 116, 117, 118, 13007, 14479, 16494, 16495, 16496, 17678, 17679, 17680, 17681, 17682, 17745, 17747, 3558, 3559, 3560, 3561, 3562, 4294, 50168, 50169, 50282, 50283, 50284, 50285, 50286, 50287, 7404, 7405, 7406, 7407, 7408, 7409, 8836, 8837, 8838, 8839, 8841, 8842, 8843, 8844, 9625, 106],
    MCH: [16497, 16498, 16499, 16500, 16501, 16502, 16503, 16504, 16766, 16889, 17206, 17209, 17749, 17750, 17751, 17752, 17753, 17754, 2864, 2866, 2868, 2870, 2872, 2873, 2874, 2876, 2878, 2890, 4276, 4675, 4676, 50117, 50119, 50288, 50289, 50290, 50291, 50292, 50293, 50294, 7410, 7411, 7412, 7413, 7414, 7415, 7416, 7418, 8848, 8849, 8850, 8851, 8853, 8855],
    DNC: [17756, 17757, 17758, 17759, 17760, 17761, 17762, 17763, 17764, 17765, 17766, 17767, 17768, 17769, 17770, 17771, 17772, 17773, 17824, 17825, 17826, 17827, 17828, 17829, 18076, 15989, 15990, 15993, 15997, 15999, 16000, 16001, 16002, 16003, 16191, 16192, 15991, 15994, 16007, 50252, 15995, 15992, 15996, 16008, 16010, 50251, 16015, 16012, 16006, 18073, 50253, 16011, 16009, 50254, 15998, 16004, 16193, 16194, 16195, 16196, 16013, 16005, 50255, 50256, 16014],
    BLM: [14477, 153, 154, 158, 159, 162, 16505, 16506, 16507, 17683, 17684, 17685, 17686, 17687, 17774, 17775, 3573, 3574, 3575, 3576, 3577, 4298, 50171, 50172, 50173, 50174, 50295, 50296, 50297, 50321, 50322, 7419, 7420, 7421, 7422, 8858, 8859, 8860, 8861, 8862, 8863, 8864, 8865, 8866, 8867, 8869, 9637, 149, 155, 141, 152],
    SMN: [16510, 16511, 16513, 16514, 16515, 16516, 16517, 16518, 16519, 16522, 16523, 16549, 16795, 16796, 16797, 16798, 16799, 16800, 16801, 16802, 16803, 17777, 17778, 17779, 17780, 17781, 17782, 17783, 17784, 17785, 180, 184, 3578, 3579, 3580, 3581, 3582, 4299, 50176, 50177, 50178, 50213, 50217, 50298, 50299, 50300, 50301, 50302, 7423, 7424, 7425, 7426, 7427, 7428, 7429, 7449, 7450, 787, 788, 791, 792, 794, 796, 797, 798, 800, 801, 8872, 8873, 8874, 8877, 8878, 8879, 8880, 8881, 9014, 9432],
    RDM: [10025, 16524, 16525, 16526, 16527, 16528, 16529, 16530, 17786, 17787, 17788, 50195, 50200, 50201, 50216, 50303, 50304, 50305, 50306, 7503, 7504, 7505, 7506, 7507, 7509, 7510, 7511, 7512, 7513, 7514, 7515, 7516, 7517, 7518, 7519, 7520, 7521, 7523, 7524, 7525, 7526, 7527, 7528, 7529, 7530, 8882, 8883, 8884, 8885, 8887, 8888, 8889, 8890, 8891, 8892, 9433, 9434],
    BLU: [11715, 11383, 11384, 11385, 11386, 11387, 11388, 11389, 11390, 11391, 11392, 11393, 11394, 11395, 11396, 11397, 11398, 11399, 11400, 11401, 11402, 11403, 11404, 11405, 11406, 11407, 11408, 11409, 11410, 11411, 11412, 11413, 11414, 11415, 11416, 11417, 11418, 11419, 11420, 11421, 11422, 11423, 11424, 11425, 11426, 11427, 11428, 11429, 11430, 11431, 50219, 50220, 50221, 50222, 50223, 50224]
  };
}
;// CONCATENATED MODULE: ./resources/stringhandlers.ts
class StringFuncs {
  static zeroPad(str, len = 2) {
    return `${str}`.padStart(len, '0');
  }
  static toProperCase(str) {
    return str.replace(/([^\W_]+[^\s-]*) */g, txt => {
      return txt.charAt(0).toUpperCase() + txt.slice(1).toLowerCase();
    });
  }
  static leftExtendStr(str, length, padChar = ' ') {
    if (str === undefined) return '';
    if (length === undefined) return str;
    return str.padStart(length, padChar);
  }
  static rightExtendStr(str, length, padChar = ' ') {
    if (str === undefined) return '';
    if (length === undefined) return str;
    return str.padEnd(length, padChar);
  }
}
/* harmony default export */ const stringhandlers = (StringFuncs);
;// CONCATENATED MODULE: ./resources/datetime.ts


// For performance reasons to prevent re-calculating this every single line,
// store already calculated values
const tzOffsetMap = {};
class DateTimeFuncs {
  static getTimezoneOffsetMillis(timeString) {
    const timezoneOffsetString = timeString.slice(-6);
    const mappedValue = tzOffsetMap[timezoneOffsetString];
    if (mappedValue) return mappedValue;
    const defaultOffset = new Date().getTimezoneOffset() * 1000;
    if (timezoneOffsetString === undefined) return defaultOffset;
    const operator = timezoneOffsetString[0];
    if (operator !== '+' && operator !== '-') return defaultOffset;
    const timezoneOffsetParts = timezoneOffsetString.slice(1).split(':');
    const hoursString = timezoneOffsetParts[0];
    const minutesString = timezoneOffsetParts[1];
    if (hoursString === undefined || minutesString === undefined) return defaultOffset;
    const hours = parseInt(hoursString);
    const minutes = parseInt(minutesString);
    const tzOffset = (hours * 60 + minutes) * 60 * 1000 * (operator === '-' ? -1 : 1);
    tzOffsetMap[timezoneOffsetString] = tzOffset;
    return tzOffset;
  }
  static timeToString(time, includeMillis = true) {
    const negative = time < 0 ? '-' : '';
    time = Math.abs(time);
    const millisNum = time % 1000;
    const secsNum = (time % (60 * 1000) - millisNum) / 1000;
    // Milliseconds
    const millis = `00${millisNum}`.slice(-3);
    const secs = `0${secsNum}`.slice(-2);
    const mins = `0${((time % (60 * 60 * 1000) - millisNum) / 1000 - secsNum) / 60}`.slice(-2);
    return `${negative + mins}:${secs}${includeMillis ? `.${millis}` : ''}`;
  }
  static timeToTimeString(time, tzOffsetMillis, includeMillis = false) {
    return this.dateObjectToTimeString(new Date(time), tzOffsetMillis, includeMillis);
  }
  static timeStringToDateString(time, tzOffsetMillis) {
    return this.dateObjectToDateString(new Date(time), tzOffsetMillis);
  }
  static dateObjectToDateString(date, tzOffsetMillis) {
    const convDate = new Date(date.getTime() + tzOffsetMillis);
    const year = convDate.getUTCFullYear();
    const month = stringhandlers.leftExtendStr((convDate.getUTCMonth() + 1).toString(), 2, '0');
    const day = stringhandlers.leftExtendStr(convDate.getUTCDate().toString(), 2, '0');
    return `${year}-${month}-${day}`;
  }
  static dateObjectToTimeString(date, tzOffsetMillis, includeMillis = true) {
    const convDate = new Date(date.getTime() + tzOffsetMillis);
    const hour = stringhandlers.leftExtendStr(convDate.getUTCHours().toString(), 2, '0');
    const minute = stringhandlers.leftExtendStr(convDate.getUTCMinutes().toString(), 2, '0');
    const second = stringhandlers.leftExtendStr(convDate.getUTCSeconds().toString(), 2, '0');
    let ret = `${hour}:${minute}:${second}`;
    if (includeMillis) ret = `${ret}.${stringhandlers.leftExtendStr(convDate.getUTCMilliseconds().toString(), 3, '0')}`;
    return ret;
  }
  static msToDuration(ms) {
    const tmp = DateTimeFuncs.timeToString(ms, false);
    return `${tmp.replace(':', 'm')}s`;
  }
  static dateTimeToString(time, tzOffsetMillis, includeMillis = false) {
    const date = new Date(time);
    const dateString = this.dateObjectToDateString(date, tzOffsetMillis);
    const timeString = this.dateObjectToTimeString(date, tzOffsetMillis, includeMillis);
    return `${dateString} ${timeString}`;
  }
}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent.ts



const fields = {
  event: 0,
  timestamp: 1
};
const unknownLogMessagePrefix = 'Unknown';
const logMessagePrefix = {};
const logDefsGeneric = netlog_defs;
for (const def of Object.values(logDefsGeneric)) {
  if (def.messageType !== undefined) logMessagePrefix[def.type] = def.messageType;
}

/**
 * Generic class to track an FFXIV log line
 */
class LineEvent {
  offset = 0;
  invalid = false;
  index = 0;
  constructor(repo, networkLine, parts) {
    this.networkLine = networkLine;
    const timestampString = parts[fields.timestamp] ?? '0';
    this.tzOffsetMillis = DateTimeFuncs.getTimezoneOffsetMillis(timestampString);
    this.decEventStr = parts[fields.event] ?? '00';
    this.decEvent = parseInt(this.decEventStr);
    this.hexEvent = stringhandlers.zeroPad(this.decEvent.toString(16).toUpperCase());
    this.timestamp = new Date(timestampString).getTime();
    this.checksum = parts.slice(-1)[0] ?? '';
    repo.updateTimestamp(this.timestamp);
    this.convertedLine = this.prefix() + parts.slice(2, -1).join(':').replace('|', ':');
  }
  prefix() {
    const timeString = DateTimeFuncs.timeToTimeString(this.timestamp, this.tzOffsetMillis, true);
    // TODO: should raidemulator not convert lines that don't come from the ffxiv plugin?
    const logMessageName = logMessagePrefix[this.decEventStr] ?? unknownLogMessagePrefix;
    return `[${timeString}] ${logMessageName} ${this.hexEvent}:`;
  }
  static isDamageHallowed(damage) {
    return (parseInt(damage, 16) & parseInt('1000', 16)) > 0;
  }
  static isDamageBig(damage) {
    return (parseInt(damage, 16) & parseInt('4000', 16)) > 0;
  }
  static calculateDamage(damage) {
    if (LineEvent.isDamageHallowed(damage)) return 0;
    damage = stringhandlers.zeroPad(damage, 8);
    const parts = [damage.slice(0, 2), damage.slice(2, 4), damage.slice(4, 6), damage.slice(6, 8)];
    if (!LineEvent.isDamageBig(damage)) return parseInt(parts.slice(0, 2).reverse().join(''), 16);
    return parseInt(parts[3] + parts[0] + (parseInt(parts[1], 16) - parseInt(parts[3], 16)).toString(16), 16);
  }
}

// Type guards for these interfaces require their own descriptor property
// because we don't want every line event with an id/name
// to update combatant state, for example
const isLineEventSource = line => {
  return 'isSource' in line;
};
const isLineEventTarget = line => {
  return 'isTarget' in line;
};
const isLineEventJobLevel = line => {
  return 'isJobLevel' in line;
};
const isLineEventAbility = line => {
  return 'isAbility' in line;
};
const isLineEvent0x03 = line => {
  return line.decEvent === 3;
};
const isLineEvent0x105 = event => {
  return event.decEvent === 261;
};
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/CombatantTracker.ts






class CombatantTracker {
  combatants = {};
  partyMembers = [];
  enemies = [];
  others = [];
  pets = [];
  constructor(logLines, language) {
    this.language = language;
    this.firstTimestamp = Number.MAX_SAFE_INTEGER;
    this.lastTimestamp = 0;
    this.initialize(logLines);
  }
  initialize(logLines) {
    this.firstTimestamp = logLines[0]?.timestamp ?? 0;
    this.lastTimestamp = logLines.slice(-1)[0]?.timestamp ?? 0;
    const eventTracker = {};
    for (const line of logLines) {
      if (isLineEventSource(line)) {
        const state = this.extractStateFromLine(line);
        this.addCombatantFromSourceLine(line, state);
        eventTracker[line.id] = eventTracker[line.id] ?? 0;
        ++eventTracker[line.id];
        this.combatants[line.id]?.pushPartialState(line.timestamp, state);
      }
      if (isLineEventTarget(line)) {
        const state = this.extractStateFromTargetLine(line);
        this.addCombatantFromTargetLine(line, state);
        eventTracker[line.targetId] = eventTracker[line.targetId] ?? 0;
        ++eventTracker[line.targetId];
        this.combatants[line.targetId]?.pushPartialState(line.timestamp, state);
      }
      if (isLineEvent0x105(line)) {
        this.addCombatantFromCombatantMemoryLine(line);
        eventTracker[line.idHex] = eventTracker[line.idHex] ?? 0;
        ++eventTracker[line.idHex];
        this.combatants[line.idHex]?.pushPartialState(line.timestamp, line.state);
      }
    }

    // Finalize combatants, cleaning up state information
    for (const combatant of Object.values(this.combatants)) combatant.finalize();

    // Figure out party/enemy/other status
    const petNames = pet_names[this.language];
    this.others = this.others.filter(ID => {
      if (this.combatants[ID]?.nextState(0).Job !== undefined && this.combatants[ID]?.nextState(0).Job !== 0 && ID.startsWith('1')) {
        this.partyMembers.push(ID);
        return false;
      } else if (petNames.includes(this.combatants[ID]?.nextState(0).Name ?? '')) {
        this.pets.push(ID);
        return false;
      } else if ((eventTracker[ID] ?? 0) > 0) {
        this.enemies.push(ID);
        return false;
      }
      return true;
    });

    // Main combatant is the one that took the most actions
    this.mainCombatantID = this.enemies.sort((l, r) => {
      return (eventTracker[r] ?? 0) - (eventTracker[l] ?? 0);
    })[0];
  }
  addCombatantFromCombatantMemoryLine(line) {
    if (this.combatants[line.idHex] === undefined) this.initCombatant(line.idHex);
  }
  addCombatantFromSourceLine(line, extractedState) {
    const combatant = this.combatants[line.id] ?? this.initCombatant(line.id);
    let initState = combatant.getTempState(this.firstTimestamp);
    const newState = new CombatantState(extractedState, initState?.targetable ?? false);
    if (line.name !== undefined) newState.setName(line.name);
    initState = combatant.pushPartialState(this.firstTimestamp, newState);
    if (isLineEventJobLevel(line)) {
      initState.Job ??= util.jobToJobEnum(line.job);
      initState.Level ??= line.level;
    }
    if (isLineEventAbility(line)) {
      if (initState.Job === undefined && !line.id.startsWith('4') && line.abilityId !== undefined) {
        const foundJob = CombatantJobSearch.getJob(line.abilityId);
        if (foundJob) initState.Job = util.jobToJobEnum(foundJob);
      }
    }
    if (isLineEvent0x03(line)) {
      if (line.npcBaseId !== undefined) initState.BNpcID = parseInt(line.npcBaseId);
      if (line.npcNameId !== undefined) initState.BNpcNameID = parseInt(line.npcNameId);
      if (line.ownerId !== undefined) initState.OwnerID = parseInt(line.ownerId);
    }
  }
  addCombatantFromTargetLine(line, extractedState) {
    const combatant = this.combatants[line.targetId] ?? this.initCombatant(line.targetId);
    let initState = combatant.getTempState(this.firstTimestamp);
    const newState = new CombatantState(extractedState, initState?.targetable ?? false);
    if (line.targetName !== undefined) newState.setName(line.targetName);
    initState = combatant.pushPartialState(this.firstTimestamp, newState);
  }
  extractStateFromLine(line) {
    const state = {};
    if (line.id !== undefined) state.ID = parseInt(line.id, 16);
    if (line.x !== undefined && !isNaN(line.x)) state.PosX = line.x;
    if (line.y !== undefined && !isNaN(line.y)) state.PosY = line.y;
    if (line.z !== undefined && !isNaN(line.z)) state.PosZ = line.z;
    if (line.heading !== undefined && !isNaN(line.heading)) state.Heading = line.heading;
    if (line.targetable !== undefined) state.targetable = line.targetable;
    if (line.hp !== undefined && !isNaN(line.hp)) state.CurrentHP = line.hp;
    if (line.maxHp !== undefined && !isNaN(line.maxHp)) state.MaxHP = line.maxHp;
    if (line.mp !== undefined && !isNaN(line.mp)) state.CurrentMP = line.mp;
    if (line.maxMp !== undefined && !isNaN(line.maxMp)) state.MaxMP = line.maxMp;
    if (line.decEvent === 4) state.targetable = false;
    return state;
  }
  extractStateFromTargetLine(line) {
    const state = {};
    if (line.targetId !== undefined) state.ID = parseInt(line.targetId, 16);
    if (line.targetX !== undefined && !isNaN(line.targetX)) state.PosX = line.targetX;
    if (line.targetY !== undefined && !isNaN(line.targetY)) state.PosY = line.targetY;
    if (line.targetZ !== undefined && !isNaN(line.targetZ)) state.PosZ = line.targetZ;
    if (line.targetHeading !== undefined && !isNaN(line.targetHeading)) state.Heading = line.targetHeading;
    if (line.targetHp !== undefined && !isNaN(line.targetHp)) state.CurrentHP = line.targetHp;
    if (line.targetMaxHp !== undefined && !isNaN(line.targetMaxHp)) state.MaxHP = line.targetMaxHp;
    if (line.targetMp !== undefined && !isNaN(line.targetMp)) state.CurrentMP = line.targetMp;
    if (line.targetMaxMp !== undefined && !isNaN(line.targetMaxMp)) state.MaxMP = line.targetMaxMp;
    return state;
  }
  initCombatant(id) {
    let combatant = this.combatants[id];
    if (combatant === undefined) {
      combatant = this.combatants[id] = new Combatant();
      this.others.push(id);
    }
    return combatant;
  }
  getMainCombatantName() {
    const defaultName = 'Unknown';
    if (this.mainCombatantID !== undefined) {
      // This gets called when persisting to indexedDB, after it has been returned from the worker
      // As such, prototypes aren't applied to combatants
      // Re-apply the prototype if needed
      const combatantObject = this.combatants[this.mainCombatantID];
      if (!combatantObject) return defaultName;
      if (Object.getPrototypeOf(combatantObject) !== Combatant.prototype) Object.setPrototypeOf(combatantObject, Combatant.prototype);
      return combatantObject.firstState.Name ?? defaultName;
    }
    return defaultName;
  }
}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LogRepository.ts
class LogRepository {
  Combatants = {};
  firstTimestamp = Number.MAX_SAFE_INTEGER;
  updateTimestamp(timestamp) {
    this.firstTimestamp = Math.min(this.firstTimestamp, timestamp);
  }
  updateCombatant(id, c) {
    id = id.toUpperCase();
    if (id && id.length) {
      let combatant = this.Combatants[id];
      if (combatant === undefined) {
        combatant = {
          name: c.name,
          job: c.job,
          spawn: c.spawn,
          despawn: c.despawn
        };
        this.Combatants[id] = combatant;
      } else {
        combatant.name = c.name ?? combatant.name;
        combatant.job = c.job ?? combatant.job;
        combatant.spawn = Math.min(combatant.spawn, c.spawn);
        combatant.despawn = Math.max(combatant.despawn, c.despawn);
      }
    }
  }
}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/EventBus.ts
// EventBus by definition requires generic parameters.
// Map our stand-in generics to actual generics here.
// eslint-disable-next-line @typescript-eslint/ban-types

// eslint-disable-next-line @typescript-eslint/no-explicit-any

/**
 * This is a base class that classes can extend to inherit event bus capabilities.
 * This allows other classes to listen for events with the `on` function.
 * The inheriting class can fire those events with the `dispatch` function.
 */
class EventBus {
  listeners = {};
  /**
   * Subscribe to an event
   *
   * @param event The event(s) to subscribe to, space separated
   * @param callback The callback to invoke
   * @param scope Optional. The scope to apply the function against
   * @returns The callbacks registered to the event(s)
   */
  on(event, callback, scope) {
    const events = event.split(' ');
    const ret = [];
    scope = scope ?? (typeof window === 'undefined' ? {} : window);
    for (const event of events) {
      const events = this.listeners[event] ??= [];
      if (callback !== undefined) events.push({
        event: event,
        scope: scope,
        callback: callback
      });
      ret.push(...(this.listeners[event] ?? []));
    }
    return ret;
  }

  /**
   * Dispatch an event to any subscribers
   *
   * @param event The event to dispatch
   * @param eventArguments The event arguments to pass to listeners
   * @returns A promise that can be await'd or ignored
   */
  async dispatch(event, ...eventArguments) {
    if (this.listeners[event] === undefined) return;
    for (const l of this.listeners[event] ?? []) {
      const res = l.callback.apply(l.scope, eventArguments);
      await Promise.resolve(res);
    }
  }
}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x00.ts


const LineEvent0x00_fields = netlog_defs.GameLog.fields;

// Chat event
class LineEvent0x00 extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.type = parts[LineEvent0x00_fields.code] ?? '';
    this.speaker = parts[LineEvent0x00_fields.name] ?? '';
    this.message = parts.slice(4, -1).join('|');

    // The exact reason for this check isn't clear anymore but may be related to
    // https://github.com/ravahn/FFXIV_ACT_Plugin/issues/250
    if (this.message.split('\u001f\u001f').length > 1) this.invalid = true;
    this.convertedLine = `${this.prefix() + this.type}:${this.speaker}:${this.message.trim()}`;
    this.convertedLine = LineEvent00.replaceChatSymbols(this.convertedLine);
  }
  static replaceChatSymbols(line) {
    for (const rep of LineEvent00.chatSymbolReplacements) line = line.replace(rep.Search, rep.Replace);
    return line;
  }
  static chatSymbolReplacements = [{
    Search: /\uE06F/g,
    Replace: '⇒',
    Type: 'Symbol'
  }, {
    Search: / \uE0BB\uE05C/g,
    Replace: ' ',
    Type: 'Positive Effect'
  }, {
    Search: / \uE0BB\uE05B/g,
    Replace: ' ',
    Type: 'Negative Effect'
  }];
}
class LineEvent00 extends LineEvent0x00 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x01.ts



const LineEvent0x01_fields = netlog_defs.ChangeZone.fields;

// Zone change event
class LineEvent0x01 extends LineEvent {
  constructor(repo, networkLine, parts) {
    super(repo, networkLine, parts);
    this.zoneId = parts[LineEvent0x01_fields.id] ?? '';
    this.zoneName = parts[LineEvent0x01_fields.name] ?? '';
    this.zoneNameProperCase = stringhandlers.toProperCase(this.zoneName);
  }
}
class LineEvent01 extends LineEvent0x01 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x02.ts


const LineEvent0x02_fields = netlog_defs.ChangedPlayer.fields;

// Player change event
class LineEvent0x02 extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x02_fields.id]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x02_fields.name] ?? '';
  }
}
class LineEvent02 extends LineEvent0x02 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x03.ts



const LineEvent0x03_fields = netlog_defs.AddedCombatant.fields;

// Added combatant event
class LineEvent0x03 extends LineEvent {
  isSource = true;
  isJobLevel = true;
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x03_fields.id]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x03_fields.name] ?? '';
    this.jobIdHex = parts[LineEvent0x03_fields.job]?.toUpperCase() ?? '';
    this.jobId = parseInt(this.jobIdHex, 16);
    this.job = util.jobEnumToJob(this.jobId);
    this.levelString = parts[LineEvent0x03_fields.level] ?? '';
    this.level = parseInt(this.levelString, 16);
    this.ownerId = parts[LineEvent0x03_fields.ownerId]?.toUpperCase() ?? '';
    this.worldId = parts[LineEvent0x03_fields.worldId] ?? '';
    this.worldName = parts[LineEvent0x03_fields.world] ?? '';
    this.npcNameId = parts[LineEvent0x03_fields.npcNameId] ?? '';
    this.npcBaseId = parts[LineEvent0x03_fields.npcBaseId] ?? '';
    this.hp = parseFloat(parts[LineEvent0x03_fields.currentHp] ?? '');
    this.maxHp = parseFloat(parts[LineEvent0x03_fields.hp] ?? '');
    this.mp = parseFloat(parts[LineEvent0x03_fields.currentMp] ?? '');
    this.maxMp = parseFloat(parts[LineEvent0x03_fields.mp] ?? '');
    this.x = parseFloat(parts[LineEvent0x03_fields.x] ?? '');
    this.y = parseFloat(parts[LineEvent0x03_fields.y] ?? '');
    this.z = parseFloat(parts[LineEvent0x03_fields.z] ?? '');
    this.heading = parseFloat(parts[LineEvent0x03_fields.heading] ?? '');
    repo.updateCombatant(this.id, {
      name: this.name,
      spawn: this.timestamp,
      despawn: this.timestamp,
      job: this.jobIdHex
    });
  }
}
class LineEvent03 extends LineEvent0x03 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x04.ts

// Removed combatant event
// Extend the add combatant event to reduce duplicate code since they're
// the same from a data perspective
class LineEvent0x04 extends LineEvent0x03 {
  constructor(repo, line, parts) {
    super(repo, line, parts);
  }
}
class LineEvent04 extends LineEvent0x04 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x0C.ts


const LineEvent0x0C_fields = netlog_defs.PlayerStats.fields;

// Player stats event
class LineEvent0x0C extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.class = parts[LineEvent0x0C_fields.job] ?? '';
    this.strength = parts[LineEvent0x0C_fields.strength] ?? '';
    this.dexterity = parts[LineEvent0x0C_fields.dexterity] ?? '';
    this.vitality = parts[LineEvent0x0C_fields.vitality] ?? '';
    this.intelligence = parts[LineEvent0x0C_fields.intelligence] ?? '';
    this.mind = parts[LineEvent0x0C_fields.mind] ?? '';
    this.piety = parts[LineEvent0x0C_fields.piety] ?? '';
    this.attackPower = parts[LineEvent0x0C_fields.attackPower] ?? '';
    this.directHit = parts[LineEvent0x0C_fields.directHit] ?? '';
    this.criticalHit = parts[LineEvent0x0C_fields.criticalHit] ?? '';
    this.attackMagicPotency = parts[LineEvent0x0C_fields.attackMagicPotency] ?? '';
    this.healMagicPotency = parts[LineEvent0x0C_fields.healMagicPotency] ?? '';
    this.determination = parts[LineEvent0x0C_fields.determination] ?? '';
    this.skillSpeed = parts[LineEvent0x0C_fields.skillSpeed] ?? '';
    this.spellSpeed = parts[LineEvent0x0C_fields.spellSpeed] ?? '';
    this.tenacity = parts[LineEvent0x0C_fields.tenacity] ?? '';
    this.localContentId = parts[LineEvent0x0C_fields.localContentId] ?? '';
  }
}
class LineEvent12 extends LineEvent0x0C {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x105.ts


const definition = netlog_defs.CombatantMemory;
const LineEvent0x105_fields = definition.fields;
const isValidChange = change => {
  return change !== undefined && ['Add', 'Change', 'Remove'].includes(change);
};
const isPluginStateKey = key => {
  return definition.repeatingFields.possibleKeys.includes(key);
};

// Combatant memory event
class LineEvent0x105 extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    const change = parts[LineEvent0x105_fields.change];
    if (isValidChange(change)) this.change = change;
    this.idHex = parts[LineEvent0x105_fields.id] ?? '';
    this.id = parseInt(this.idHex, 16);
    const stateSets = parts.slice(definition.repeatingFields.startingIndex, -1);
    const stringStateMap = {};
    for (let i = 0; i < stateSets.length; i += 2) {
      const key = stateSets[i];
      const value = stateSets[i + 1];
      if (key === undefined || value === undefined) continue;
      if (!isPluginStateKey(key)) continue;
      stringStateMap[key] = value;
    }
    this.state = {};

    // Strings
    if (stringStateMap.Distance !== undefined) this.state.Distance = stringStateMap.Distance;
    if (stringStateMap.EffectiveDistance !== undefined) this.state.EffectiveDistance = stringStateMap.EffectiveDistance;
    if (stringStateMap.Name !== undefined) this.state.Name = stringStateMap.Name;
    if (stringStateMap.WorldName !== undefined) this.state.WorldName = stringStateMap.WorldName;

    // Booleans
    if (stringStateMap.IsTargetable !== undefined) this.state.IsTargetable = Boolean(parseInt(stringStateMap.IsTargetable));

    // Base-16 numbers (IDs)
    if (stringStateMap.BNpcID !== undefined) this.state.BNpcID = parseInt(stringStateMap.BNpcID, 16);
    if (stringStateMap.BNpcNameID !== undefined) this.state.BNpcNameID = parseInt(stringStateMap.BNpcNameID, 16);
    if (stringStateMap.NPCTargetID !== undefined) this.state.NPCTargetID = parseInt(stringStateMap.NPCTargetID, 16);
    if (stringStateMap.PCTargetID !== undefined) this.state.PCTargetID = parseInt(stringStateMap.PCTargetID, 16);
    if (stringStateMap.OwnerID !== undefined) this.state.OwnerID = parseInt(stringStateMap.OwnerID, 16);
    if (stringStateMap.TargetID !== undefined) this.state.TargetID = parseInt(stringStateMap.TargetID, 16);
    if (stringStateMap.CastTargetID !== undefined) this.state.CastTargetID = parseInt(stringStateMap.CastTargetID, 16);

    // Numbers
    if (stringStateMap.CurrentWorldID !== undefined) this.state.CurrentWorldID = parseFloat(stringStateMap.CurrentWorldID);
    if (stringStateMap.WorldID !== undefined) this.state.WorldID = parseFloat(stringStateMap.WorldID);
    if (stringStateMap.PartyType !== undefined) this.state.PartyType = parseFloat(stringStateMap.PartyType);
    if (stringStateMap.ID !== undefined) this.state.ID = parseFloat(stringStateMap.ID);
    if (stringStateMap.WeaponId !== undefined) this.state.WeaponId = parseFloat(stringStateMap.WeaponId);
    if (stringStateMap.Type !== undefined) this.state.Type = parseFloat(stringStateMap.Type);
    if (stringStateMap.Job !== undefined) this.state.Job = parseFloat(stringStateMap.Job);
    if (stringStateMap.Level !== undefined) this.state.Level = parseFloat(stringStateMap.Level);
    if (stringStateMap.CurrentHP !== undefined) this.state.CurrentHP = parseFloat(stringStateMap.CurrentHP);
    if (stringStateMap.MaxHP !== undefined) this.state.MaxHP = parseFloat(stringStateMap.MaxHP);
    if (stringStateMap.CurrentMP !== undefined) this.state.CurrentMP = parseFloat(stringStateMap.CurrentMP);
    if (stringStateMap.MaxMP !== undefined) this.state.MaxMP = parseFloat(stringStateMap.MaxMP);
    if (stringStateMap.PosX !== undefined) this.state.PosX = parseFloat(stringStateMap.PosX);
    if (stringStateMap.PosY !== undefined) this.state.PosY = parseFloat(stringStateMap.PosY);
    if (stringStateMap.PosZ !== undefined) this.state.PosZ = parseFloat(stringStateMap.PosZ);
    if (stringStateMap.Heading !== undefined) this.state.Heading = parseFloat(stringStateMap.Heading);
    if (stringStateMap.MonsterType !== undefined) this.state.MonsterType = parseFloat(stringStateMap.MonsterType);
    if (stringStateMap.Status !== undefined) this.state.Status = parseFloat(stringStateMap.Status);
    if (stringStateMap.ModelStatus !== undefined) this.state.ModelStatus = parseFloat(stringStateMap.ModelStatus);
    if (stringStateMap.AggressionStatus !== undefined) this.state.AggressionStatus = parseFloat(stringStateMap.AggressionStatus);
    if (stringStateMap.Radius !== undefined) this.state.Radius = parseFloat(stringStateMap.Radius);
    if (stringStateMap.CurrentGP !== undefined) this.state.CurrentGP = parseFloat(stringStateMap.CurrentGP);
    if (stringStateMap.MaxGP !== undefined) this.state.MaxGP = parseFloat(stringStateMap.MaxGP);
    if (stringStateMap.CurrentCP !== undefined) this.state.CurrentCP = parseFloat(stringStateMap.CurrentCP);
    if (stringStateMap.MaxCP !== undefined) this.state.MaxCP = parseFloat(stringStateMap.MaxCP);
    if (stringStateMap.IsCasting1 !== undefined) this.state.IsCasting1 = parseFloat(stringStateMap.IsCasting1);
    if (stringStateMap.IsCasting2 !== undefined) this.state.IsCasting2 = parseFloat(stringStateMap.IsCasting2);
    if (stringStateMap.CastBuffID !== undefined) this.state.CastBuffID = parseFloat(stringStateMap.CastBuffID);
    if (stringStateMap.CastDurationCurrent !== undefined) this.state.CastDurationCurrent = parseFloat(stringStateMap.CastDurationCurrent);
    if (stringStateMap.CastDurationMax !== undefined) this.state.CastDurationMax = parseFloat(stringStateMap.CastDurationMax);
    if (stringStateMap.TransformationId !== undefined) this.state.TransformationId = parseFloat(stringStateMap.TransformationId);
  }
}
class LineEvent261 extends LineEvent0x105 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x14.ts


const LineEvent0x14_fields = netlog_defs.StartsUsing.fields;

// Shorten a few types so dprint doesn't complain when the line gets too long.

// Ability use event
class LineEvent0x14 extends LineEvent {
  isSource = true;
  isTarget = true;
  isAbility = true;
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x14_fields.sourceId]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x14_fields.source] ?? '';
    this.abilityIdHex = parts[LineEvent0x14_fields.id]?.toUpperCase() ?? '';
    this.abilityId = parseInt(this.abilityIdHex, 16);
    this.abilityName = parts[LineEvent0x14_fields.ability] ?? '';
    this.targetId = parts[LineEvent0x14_fields.targetId]?.toUpperCase() ?? '';
    this.targetName = parts[LineEvent0x14_fields.target] ?? '';
    this.duration = parts[LineEvent0x14_fields.castTime] ?? '';
    this.x = parseFloat(parts[LineEvent0x14_fields.x] ?? '');
    this.y = parseFloat(parts[LineEvent0x14_fields.y] ?? '');
    this.z = parseFloat(parts[LineEvent0x14_fields.z] ?? '');
    this.heading = parseFloat(parts[LineEvent0x14_fields.heading] ?? '');
    repo.updateCombatant(this.id, {
      job: undefined,
      name: this.name,
      spawn: this.timestamp,
      despawn: this.timestamp
    });
    repo.updateCombatant(this.targetId, {
      job: undefined,
      name: this.targetName,
      spawn: this.timestamp,
      despawn: this.timestamp
    });
  }
}
class LineEvent20 extends LineEvent0x14 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x15.ts


const LineEvent0x15_fields = netlog_defs.Ability.fields;

// Shorten a few types so dprint doesn't complain when the line gets too long.

// Ability hit single target event
class LineEvent0x15 extends LineEvent {
  isSource = true;
  isTarget = true;
  isAbility = true;
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x15_fields.sourceId]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x15_fields.source] ?? '';
    this.flags = parts[LineEvent0x15_fields.flags] ?? '';
    const fieldOffset = this.flags === '3F' ? 2 : 0;
    this.damage = LineEvent.calculateDamage(parts[LineEvent0x15_fields.damage + fieldOffset] ?? '');
    this.abilityId = parseInt(parts[LineEvent0x15_fields.id]?.toUpperCase() ?? '', 16);
    this.abilityName = parts[LineEvent0x15_fields.ability] ?? '';
    this.targetId = parts[LineEvent0x15_fields.targetId]?.toUpperCase() ?? '';
    this.targetName = parts[LineEvent0x15_fields.target] ?? '';
    this.targetHp = parseInt(parts[LineEvent0x15_fields.targetCurrentHp + fieldOffset] ?? '');
    this.targetMaxHp = parseInt(parts[LineEvent0x15_fields.targetMaxHp + fieldOffset] ?? '');
    this.targetMp = parseInt(parts[LineEvent0x15_fields.targetCurrentMp + fieldOffset] ?? '');
    this.targetMaxMp = parseInt(parts[LineEvent0x15_fields.targetMaxMp + fieldOffset] ?? '');
    this.targetX = parseFloat(parts[LineEvent0x15_fields.targetX + fieldOffset] ?? '');
    this.targetY = parseFloat(parts[LineEvent0x15_fields.targetY + fieldOffset] ?? '');
    this.targetZ = parseFloat(parts[LineEvent0x15_fields.targetZ + fieldOffset] ?? '');
    this.targetHeading = parseFloat(parts[LineEvent0x15_fields.targetHeading + fieldOffset] ?? '');
    this.hp = parseInt(parts[LineEvent0x15_fields.currentHp + fieldOffset] ?? '');
    this.maxHp = parseInt(parts[LineEvent0x15_fields.maxHp + fieldOffset] ?? '');
    this.mp = parseInt(parts[LineEvent0x15_fields.currentMp + fieldOffset] ?? '');
    this.maxMp = parseInt(parts[LineEvent0x15_fields.maxMp + fieldOffset] ?? '');
    this.x = parseFloat(parts[LineEvent0x15_fields.x + fieldOffset] ?? '');
    this.y = parseFloat(parts[LineEvent0x15_fields.y + fieldOffset] ?? '');
    this.z = parseFloat(parts[LineEvent0x15_fields.z + fieldOffset] ?? '');
    this.heading = parseFloat(parts[LineEvent0x15_fields.heading + fieldOffset] ?? '');
    repo.updateCombatant(this.id, {
      job: undefined,
      name: this.name,
      spawn: this.timestamp,
      despawn: this.timestamp
    });
    repo.updateCombatant(this.targetId, {
      job: undefined,
      name: this.targetName,
      spawn: this.timestamp,
      despawn: this.timestamp
    });
  }
}
class LineEvent21 extends LineEvent0x15 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x16.ts

// Ability hit multiple/no target event
// Duplicate of 0x15 as far as data
class LineEvent0x16 extends LineEvent0x15 {
  constructor(repo, line, parts) {
    super(repo, line, parts);
  }
}
class LineEvent22 extends LineEvent0x16 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x17.ts


const LineEvent0x17_fields = netlog_defs.NetworkCancelAbility.fields;

// Cancel ability event
class LineEvent0x17 extends LineEvent {
  isSource = true;
  isAbility = true;
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x17_fields.sourceId]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x17_fields.name] ?? '';
    this.abilityId = parseInt(parts[LineEvent0x17_fields.id]?.toUpperCase() ?? '', 16);
    this.abilityName = parts[LineEvent0x17_fields.name] ?? '';
    this.reason = parts[LineEvent0x17_fields.reason] ?? '';
  }
}
class LineEvent23 extends LineEvent0x17 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x18.ts


const LineEvent0x18_fields = netlog_defs.NetworkDoT.fields;

// DoT/HoT event
class LineEvent0x18 extends LineEvent {
  isSource = true;
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x18_fields.id]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x18_fields.name] ?? '';
    this.which = parts[LineEvent0x18_fields.which] ?? '';
    this.effectId = parts[LineEvent0x18_fields.effectId]?.toUpperCase() ?? '';
    const damageString = parts[LineEvent0x18_fields.damage] ?? '';
    this.damage = parseInt(damageString, 16);
    this.hp = parseInt(parts[LineEvent0x18_fields.currentHp] ?? '');
    this.maxHp = parseInt(parts[LineEvent0x18_fields.maxHp] ?? '');
    this.mp = parseInt(parts[LineEvent0x18_fields.currentMp] ?? '');
    this.maxMp = parseInt(parts[LineEvent0x18_fields.maxMp] ?? '');
    this.x = parseFloat(parts[LineEvent0x18_fields.x] ?? '');
    this.y = parseFloat(parts[LineEvent0x18_fields.y] ?? '');
    this.z = parseFloat(parts[LineEvent0x18_fields.z] ?? '');
    this.heading = parseFloat(parts[LineEvent0x18_fields.heading] ?? '');
    repo.updateCombatant(this.id, {
      job: undefined,
      name: this.name,
      spawn: this.timestamp,
      despawn: this.timestamp
    });
  }
}
class LineEvent24 extends LineEvent0x18 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x19.ts


const LineEvent0x19_fields = netlog_defs.WasDefeated.fields;

// Combatant defeated event
class LineEvent0x19 extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.targetId = parts[LineEvent0x19_fields.targetId]?.toUpperCase() ?? '';
    this.targetName = parts[LineEvent0x19_fields.target] ?? '';
    this.sourceId = parts[LineEvent0x19_fields.sourceId]?.toUpperCase() ?? '';
    this.sourceName = parts[LineEvent0x19_fields.source] ?? '';
    repo.updateCombatant(this.sourceId, {
      job: undefined,
      name: this.sourceName,
      spawn: this.timestamp,
      despawn: this.timestamp
    });
    repo.updateCombatant(this.targetId, {
      job: undefined,
      name: this.targetName,
      spawn: this.timestamp,
      despawn: this.timestamp
    });
  }
}
class LineEvent25 extends LineEvent0x19 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x1A.ts


const LineEvent0x1A_fields = netlog_defs.GainsEffect.fields;

// Gain status effect event
// Deliberately don't flag this as LineEventSource or LineEventTarget
// because 0x1A line values aren't accurate
class LineEvent0x1A extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.effectId = parseInt(parts[LineEvent0x1A_fields.effectId]?.toUpperCase() ?? '', 16);
    this.effect = parts[LineEvent0x1A_fields.effect] ?? '';
    this.durationString = parts[LineEvent0x1A_fields.duration] ?? '';
    this.durationFloat = parseFloat(this.durationString);
    this.id = parts[LineEvent0x1A_fields.sourceId]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x1A_fields.source] ?? '';
    this.targetId = parts[LineEvent0x1A_fields.targetId]?.toUpperCase() ?? '';
    this.targetName = parts[LineEvent0x1A_fields.target] ?? '';
    this.stacks = parseInt(parts[LineEvent0x1A_fields.count] ?? '0');
    this.targetMaxHp = parseInt(parts[LineEvent0x1A_fields.targetMaxHp] ?? '');
    this.sourceMaxHp = parseInt(parts[LineEvent0x1A_fields.sourceMaxHp] ?? '');
    repo.updateCombatant(this.id, {
      name: this.name,
      spawn: this.timestamp,
      despawn: this.timestamp,
      job: undefined
    });
    repo.updateCombatant(this.targetId, {
      name: this.targetName,
      spawn: this.timestamp,
      despawn: this.timestamp,
      job: undefined
    });
  }
}
class LineEvent26 extends LineEvent0x1A {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x1B.ts


const LineEvent0x1B_fields = netlog_defs.HeadMarker.fields;

// Head marker event
class LineEvent0x1B extends LineEvent {
  isSource = true;
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x1B_fields.targetId]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x1B_fields.target] ?? '';
    this.headmarkerId = parts[LineEvent0x1B_fields.id] ?? '';
  }
}
class LineEvent27 extends LineEvent0x1B {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x1C.ts


const LineEvent0x1C_fields = netlog_defs.NetworkRaidMarker.fields;

// Floor waymarker event
class LineEvent0x1C extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.operation = parts[LineEvent0x1C_fields.operation] ?? '';
    this.waymark = parts[LineEvent0x1C_fields.waymark] ?? '';
    this.id = parts[LineEvent0x1C_fields.id]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x1C_fields.name] ?? '';
    this.x = parts[LineEvent0x1C_fields.x] ?? '';
    this.y = parts[LineEvent0x1C_fields.y] ?? '';
    this.z = parts[LineEvent0x1C_fields.z] ?? '';
  }
}
class LineEvent28 extends LineEvent0x1C {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x1D.ts


const LineEvent0x1D_fields = netlog_defs.NetworkTargetMarker.fields;

// Waymarker
class LineEvent0x1D extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.operation = parts[LineEvent0x1D_fields.operation] ?? '';
    this.waymark = parts[LineEvent0x1D_fields.waymark] ?? '';
    this.id = parts[LineEvent0x1D_fields.id]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x1D_fields.name] ?? '';
    this.targetId = parts[LineEvent0x1D_fields.targetId]?.toUpperCase() ?? '';
    this.targetName = parts[LineEvent0x1D_fields.targetName] ?? '';
  }
}
class LineEvent29 extends LineEvent0x1D {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x1E.ts

// Lose status effect event
// Extend the gain status event to reduce duplicate code since they're
// the same from a data perspective
class LineEvent0x1E extends LineEvent0x1A {
  constructor(repo, line, parts) {
    super(repo, line, parts);
  }
}
class LineEvent30 extends LineEvent0x1E {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x1F.ts



const splitFunc = s => [s.slice(6, 8), s.slice(4, 6), s.slice(2, 4), s.slice(0, 2)];
const LineEvent0x1F_fields = netlog_defs.NetworkGauge.fields;

// Job gauge event
class LineEvent0x1F extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x1F_fields.id]?.toUpperCase() ?? '';
    this.dataBytes1 = stringhandlers.zeroPad(parts[LineEvent0x1F_fields.data0] ?? '');
    this.dataBytes2 = stringhandlers.zeroPad(parts[LineEvent0x1F_fields.data1] ?? '');
    this.dataBytes3 = stringhandlers.zeroPad(parts[LineEvent0x1F_fields.data2] ?? '');
    this.dataBytes4 = stringhandlers.zeroPad(parts[LineEvent0x1F_fields.data3] ?? '');
    this.jobGaugeBytes = [...splitFunc(this.dataBytes1), ...splitFunc(this.dataBytes2), ...splitFunc(this.dataBytes3), ...splitFunc(this.dataBytes4)];
    this.name = repo.Combatants[this.id]?.name ?? '';
    repo.updateCombatant(this.id, {
      name: repo.Combatants[this.id]?.name,
      spawn: this.timestamp,
      despawn: this.timestamp,
      job: this.jobGaugeBytes[0]?.toUpperCase()
    });
  }
}
class LineEvent31 extends LineEvent0x1F {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x22.ts


const LineEvent0x22_fields = netlog_defs.NameToggle.fields;

// Nameplate toggle
class LineEvent0x22 extends LineEvent {
  isSource = true;
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x22_fields.id]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x22_fields.name] ?? '';
    this.targetId = parts[LineEvent0x22_fields.targetId]?.toUpperCase() ?? '';
    this.targetName = parts[LineEvent0x22_fields.targetName] ?? '';
    this.targetable = !!parseInt(parts[LineEvent0x22_fields.toggle] ?? '', 16);
  }
}
class LineEvent34 extends LineEvent0x22 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x23.ts


const LineEvent0x23_fields = netlog_defs.Tether.fields;

// Tether event
class LineEvent0x23 extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x23_fields.sourceId]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x23_fields.source] ?? '';
    this.targetId = parts[LineEvent0x23_fields.targetId]?.toUpperCase() ?? '';
    this.targetName = parts[LineEvent0x23_fields.target] ?? '';
    this.tetherId = parts[LineEvent0x23_fields.id] ?? '';
  }
}
class LineEvent35 extends LineEvent0x23 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x24.ts


const LineEvent0x24_fields = netlog_defs.LimitBreak.fields;

// Limit gauge event
class LineEvent0x24 extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.valueHex = parts[LineEvent0x24_fields.valueHex] ?? '';
    this.valueDec = parseInt(this.valueHex, 16);
    this.bars = parts[LineEvent0x24_fields.bars] ?? '';
  }
}
class LineEvent36 extends LineEvent0x24 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x25.ts


const LineEvent0x25_fields = netlog_defs.NetworkEffectResult.fields;

// Action sync event
class LineEvent0x25 extends LineEvent {
  isSource = true;
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x25_fields.id]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x25_fields.name] ?? '';
    this.sequenceId = parts[LineEvent0x25_fields.sequenceId] ?? '';
    this.hp = parseInt(parts[LineEvent0x25_fields.currentHp] ?? '');
    this.maxHp = parseInt(parts[LineEvent0x25_fields.maxHp] ?? '');
    this.mp = parseInt(parts[LineEvent0x25_fields.currentMp] ?? '');
    this.maxMp = parseInt(parts[LineEvent0x25_fields.maxMp] ?? '');
    this.x = parseFloat(parts[LineEvent0x25_fields.x] ?? '');
    this.y = parseFloat(parts[LineEvent0x25_fields.y] ?? '');
    this.z = parseFloat(parts[LineEvent0x25_fields.z] ?? '');
    this.heading = parseFloat(parts[LineEvent0x25_fields.heading] ?? '');
  }
}
class LineEvent37 extends LineEvent0x25 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x26.ts




const LineEvent0x26_fields = netlog_defs.StatusEffect.fields;

// Network status effect event
class LineEvent0x26 extends LineEvent {
  isSource = true;
  isJobLevel = true;
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x26_fields.targetId]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x26_fields.target] ?? '';
    this.jobLevelData = parts[LineEvent0x26_fields.jobLevelData] ?? '';
    this.hp = parseInt(parts[LineEvent0x26_fields.hp] ?? '');
    this.maxHp = parseInt(parts[LineEvent0x26_fields.maxHp] ?? '');
    this.mp = parseInt(parts[LineEvent0x26_fields.mp] ?? '');
    this.maxMp = parseInt(parts[LineEvent0x26_fields.maxMp] ?? '');
    this.x = parseFloat(parts[LineEvent0x26_fields.x] ?? '');
    this.y = parseFloat(parts[LineEvent0x26_fields.y] ?? '');
    this.z = parseFloat(parts[LineEvent0x26_fields.z] ?? '');
    this.heading = parseFloat(parts[LineEvent0x26_fields.heading] ?? '');
    const padded = stringhandlers.zeroPad(this.jobLevelData, 8);
    this.jobIdHex = padded.slice(6, 8).toUpperCase();
    this.jobId = parseInt(this.jobIdHex, 16);
    this.job = util.jobEnumToJob(this.jobId);
    this.level = parseInt(padded.slice(4, 6), 16);
  }
}
class LineEvent38 extends LineEvent0x26 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x27.ts


const LineEvent0x27_fields = netlog_defs.NetworkUpdateHP.fields;

// Network update hp event
class LineEvent0x27 extends LineEvent {
  isSource = true;
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x27_fields.id]?.toUpperCase() ?? '';
    this.name = parts[LineEvent0x27_fields.name] ?? '';
    this.hp = parseInt(parts[LineEvent0x27_fields.currentHp] ?? '');
    this.maxHp = parseInt(parts[LineEvent0x27_fields.maxHp] ?? '');
    this.mp = parseInt(parts[LineEvent0x27_fields.currentMp] ?? '');
    this.maxMp = parseInt(parts[LineEvent0x27_fields.maxMp] ?? '');
    this.x = parseFloat(parts[LineEvent0x27_fields.x] ?? '');
    this.y = parseFloat(parts[LineEvent0x27_fields.y] ?? '');
    this.z = parseFloat(parts[LineEvent0x27_fields.z] ?? '');
    this.heading = parseFloat(parts[LineEvent0x27_fields.heading] ?? '');
  }
}
class LineEvent39 extends LineEvent0x27 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x28.ts


const LineEvent0x28_fields = netlog_defs.Map.fields;

// ChangeMap event
class LineEvent0x28 extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.id = parts[LineEvent0x28_fields.id] ?? '';
    this.regionName = parts[LineEvent0x28_fields.regionName] ?? '';
    this.placeName = parts[LineEvent0x28_fields.placeName] ?? '';
    this.placeNameSub = parts[LineEvent0x28_fields.placeNameSub] ?? '';
  }
}
class LineEvent40 extends LineEvent0x28 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/LineEvent0x29.ts


const LineEvent0x29_fields = netlog_defs.SystemLogMessage.fields;

// SystemLogMessage event
class LineEvent0x29 extends LineEvent {
  constructor(repo, line, parts) {
    super(repo, line, parts);
    this.instance = parts[LineEvent0x29_fields.instance] ?? '';
    this.id = parts[LineEvent0x29_fields.id] ?? '';
    this.param0 = parts[LineEvent0x29_fields.param0] ?? '';
    this.param1 = parts[LineEvent0x29_fields.param1] ?? '';
    this.param2 = parts[LineEvent0x29_fields.param2] ?? '';
  }
}
class LineEvent41 extends LineEvent0x29 {}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/network_log_converter/ParseLine.ts




























class ParseLine {
  static parse(repo, line) {
    let ret;
    const parts = line.split('|');
    const event = parts[0];

    // Don't parse raw network packet lines
    if (event === undefined || event === '252') return;

    // This is ugly, but Webpack prefers being explicit
    switch (`LineEvent${event}`) {
      case 'LineEvent00':
        ret = new LineEvent00(repo, line, parts);
        break;
      case 'LineEvent01':
        ret = new LineEvent01(repo, line, parts);
        break;
      case 'LineEvent02':
        ret = new LineEvent02(repo, line, parts);
        break;
      case 'LineEvent03':
        ret = new LineEvent03(repo, line, parts);
        break;
      case 'LineEvent04':
        ret = new LineEvent04(repo, line, parts);
        break;
      case 'LineEvent12':
        ret = new LineEvent12(repo, line, parts);
        break;
      case 'LineEvent20':
        ret = new LineEvent20(repo, line, parts);
        break;
      case 'LineEvent21':
        ret = new LineEvent21(repo, line, parts);
        break;
      case 'LineEvent22':
        ret = new LineEvent22(repo, line, parts);
        break;
      case 'LineEvent23':
        ret = new LineEvent23(repo, line, parts);
        break;
      case 'LineEvent24':
        ret = new LineEvent24(repo, line, parts);
        break;
      case 'LineEvent25':
        ret = new LineEvent25(repo, line, parts);
        break;
      case 'LineEvent26':
        ret = new LineEvent26(repo, line, parts);
        break;
      case 'LineEvent27':
        ret = new LineEvent27(repo, line, parts);
        break;
      case 'LineEvent28':
        ret = new LineEvent28(repo, line, parts);
        break;
      case 'LineEvent29':
        ret = new LineEvent29(repo, line, parts);
        break;
      case 'LineEvent30':
        ret = new LineEvent30(repo, line, parts);
        break;
      case 'LineEvent31':
        ret = new LineEvent31(repo, line, parts);
        break;
      case 'LineEvent34':
        ret = new LineEvent34(repo, line, parts);
        break;
      case 'LineEvent35':
        ret = new LineEvent35(repo, line, parts);
        break;
      case 'LineEvent36':
        ret = new LineEvent36(repo, line, parts);
        break;
      case 'LineEvent37':
        ret = new LineEvent37(repo, line, parts);
        break;
      case 'LineEvent38':
        ret = new LineEvent38(repo, line, parts);
        break;
      case 'LineEvent39':
        ret = new LineEvent39(repo, line, parts);
        break;
      case 'LineEvent40':
        ret = new LineEvent40(repo, line, parts);
        break;
      case 'LineEvent41':
        ret = new LineEvent41(repo, line, parts);
        break;
      case 'LineEvent261':
        ret = new LineEvent261(repo, line, parts);
        break;
      default:
        ret = new LineEvent(repo, line, parts);
    }

    // Also don't parse lines with a non-sane date. This is 2000-01-01 00:00:00
    if (ret.timestamp < 946684800) return;

    // Finally, if the object marks itself as invalid, skip it
    if (ret.invalid) return;
    return ret;
  }
}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/NetworkLogConverter.ts



const isLineEvent = line => {
  return !!line;
};
class NetworkLogConverter extends EventBus {
  convertFile(data) {
    const repo = new LogRepository();
    return this.convertLines(
    // Split data into an array of separate lines, removing any blank lines.
    data.split(NetworkLogConverter.lineSplitRegex).filter(l => l !== ''), repo);
  }
  convertLines(lines, repo) {
    return lines.map(l => ParseLine.parse(repo, l)).filter(isLineEvent);
  }
  static lineSplitRegex = /\r?\n/gm;
}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/Encounter.ts








const isPetName = (name, language) => {
  if (language) return pet_names[language].includes(name);
  for (const lang in pet_names) {
    if (!isLang(lang)) throw new not_reached_UnreachableCode();
    if (pet_names[lang].includes(name)) return true;
  }
  return false;
};
const isValidTimestamp = timestamp => {
  return timestamp > 0 && timestamp < Number.MAX_SAFE_INTEGER;
};
class Encounter {
  static encounterVersion = 2;
  initialOffset = Number.MAX_SAFE_INTEGER;
  endStatus = 'Unknown';
  startStatus = 'Unknown';
  engageAt = Number.MAX_SAFE_INTEGER;
  firstPlayerAbility = Number.MAX_SAFE_INTEGER;
  firstEnemyAbility = Number.MAX_SAFE_INTEGER;
  firstLineIndex = 0;
  startTimestamp = 0;
  endTimestamp = 0;
  duration = 0;
  tzOffsetMillis = 0;
  playbackOffset = 0;
  language = 'en';
  initialTimestamp = Number.MAX_SAFE_INTEGER;
  constructor(encounterDay, encounterZoneId, encounterZoneName, logLines) {
    this.encounterDay = encounterDay;
    this.encounterZoneId = encounterZoneId;
    this.encounterZoneName = encounterZoneName;
    this.logLines = logLines;
    this.version = Encounter.encounterVersion;
  }
  initialize() {
    const startStatuses = new Set();
    for (const line of this.logLines) {
      this.tzOffsetMillis = line.tzOffsetMillis;
      let res = EmulatorCommon.matchStart(line.networkLine);
      if (res) {
        this.firstLineIndex = line.index;
        if (res.StartType) startStatuses.add(res.StartType);
        const startIn = parseInt(res.StartIn);
        if (startIn >= 0) this.engageAt = Math.min(line.timestamp + startIn, this.engageAt);
      } else {
        res = EmulatorCommon.matchEnd(line.networkLine);
        if (res) {
          if (res.EndType) this.endStatus = res.EndType;
        } else if (isLineEventSource(line) && isLineEventTarget(line)) {
          if (line.id.startsWith('1') || line.id.startsWith('4') && isPetName(line.name, this.language)) {
            // Player or pet ability
            if (line.targetId.startsWith('4') && !isPetName(line.targetName, this.language)) {
              // Targetting non player or pet
              this.firstPlayerAbility = Math.min(this.firstPlayerAbility, line.timestamp);
            }
          } else if (line.id.startsWith('4') && !isPetName(line.name, this.language)) {
            // Non-player ability
            if (line.targetId.startsWith('1') || isPetName(line.targetName, this.language)) {
              // Targetting player or pet
              this.firstEnemyAbility = Math.min(this.firstEnemyAbility, line.timestamp);
            }
          }
        }
      }
      const matchedLang = res?.language;
      if (isLang(matchedLang)) this.language = matchedLang;
    }
    this.combatantTracker = new CombatantTracker(this.logLines, this.language);
    this.startTimestamp = this.combatantTracker.firstTimestamp;
    this.endTimestamp = this.combatantTracker.lastTimestamp;
    this.duration = this.endTimestamp - this.startTimestamp;
    if (this.initialOffset === Number.MAX_SAFE_INTEGER) {
      if (this.engageAt < Number.MAX_SAFE_INTEGER) this.initialOffset = this.engageAt - this.startTimestamp;else if (this.firstPlayerAbility < Number.MAX_SAFE_INTEGER) this.initialOffset = this.firstPlayerAbility - this.startTimestamp;else if (this.firstEnemyAbility < Number.MAX_SAFE_INTEGER) this.initialOffset = this.firstEnemyAbility - this.startTimestamp;else this.initialOffset = 0;
    }
    this.initialTimestamp = this.startTimestamp + this.initialOffset;
    const firstLine = this.logLines[this.firstLineIndex];
    if (firstLine && firstLine.offset) this.playbackOffset = firstLine.offset;
    this.startStatus = [...startStatuses].sort().join(', ');
  }
  shouldPersistFight() {
    return isValidTimestamp(this.firstPlayerAbility) && isValidTimestamp(this.firstEnemyAbility);
  }
  upgrade(version) {
    if (Encounter.encounterVersion <= version) return false;
    const repo = new LogRepository();
    const converter = new NetworkLogConverter();
    this.logLines = converter.convertLines(this.logLines.map(l => l.networkLine), repo);
    this.version = Encounter.encounterVersion;
    this.initialize();
    return true;
  }
}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/LogEventHandler.ts



class LogEventHandler extends EventBus {
  currentFight = [];
  currentZoneName = 'Unknown';
  currentZoneId = '-1';
  parseLogs(logs) {
    for (const lineObj of logs) {
      this.currentFight.push(lineObj);
      lineObj.offset = lineObj.timestamp - this.currentFightStart;
      const res = EmulatorCommon.matchEnd(lineObj.networkLine);
      if (res) {
        this.endFight();
      } else if (lineObj instanceof LineEvent0x01) {
        this.currentZoneId = lineObj.zoneId;
        this.currentZoneName = lineObj.zoneName;
        this.endFight();
      }
    }
  }
  get currentFightStart() {
    return this.currentFight[0]?.timestamp ?? 0;
  }
  get currentFightEnd() {
    return this.currentFight.slice(-1)[0]?.timestamp ?? 0;
  }
  endFight() {
    if (this.currentFight.length < 2) return;
    const start = new Date(this.currentFightStart).toISOString();
    const end = new Date(this.currentFightEnd).toISOString();
    console.debug(`Dispatching new fight
Start: ${start}
End: ${end}
Zone: ${this.currentZoneName}
Line Count: ${this.currentFight.length}
`);
    void this.dispatch('fight', start.slice(0, 10), this.currentZoneId, this.currentZoneName, this.currentFight);
    this.currentFight = [];
  }
}
;// CONCATENATED MODULE: ./ui/raidboss/emulator/data/NetworkLogConverter.worker.ts





const ctx = self;
ctx.addEventListener('message', msg => {
  if (!(msg.data instanceof ArrayBuffer)) {
    // TODO: should this return an 'error' instead?
    ctx.postMessage({
      type: 'done'
    });
    throw new not_reached_UnreachableCode();
  }
  const logConverter = new NetworkLogConverter();
  const localLogHandler = new LogEventHandler();
  const repo = new LogRepository();

  // Listen for LogEventHandler to dispatch fights and persist them
  localLogHandler.on('fight', (day, zoneId, zoneName, lines) => {
    // Index the lines for this encounter
    for (let i = 0; i < lines.length; ++i) {
      const line = lines[i];
      if (!line) throw new not_reached_UnreachableCode();
      line.index = i;
    }
    const enc = new Encounter(day, zoneId, zoneName, lines);
    enc.initialize();
    if (enc.shouldPersistFight()) {
      ctx.postMessage({
        type: 'encounter',
        encounter: enc,
        name: enc.combatantTracker?.getMainCombatantName()
      });
    }
  });

  // Convert the message manually due to memory issues with extremely large files
  const decoder = new TextDecoder('UTF-8');
  let buf = new Uint8Array(msg.data);
  let nextOffset = 0;
  let lines = [];
  let lineCount = 0;
  for (let currentOffset = nextOffset; nextOffset < buf.length && nextOffset !== -1; currentOffset = nextOffset) {
    nextOffset = buf.indexOf(0x0A, nextOffset + 1);
    const line = decoder.decode(buf.slice(currentOffset, nextOffset)).trim();
    if (line.length) {
      ++lineCount;
      lines.push(line);
    }
    if (lines.length >= 1000) {
      lines = logConverter.convertLines(lines, repo);
      localLogHandler.parseLogs(lines);
      ctx.postMessage({
        type: 'progress',
        lines: lineCount,
        bytes: nextOffset,
        totalBytes: buf.length
      });
      lines = [];
    }
  }
  if (lines.length > 0) {
    lines = logConverter.convertLines(lines, repo);
    localLogHandler.parseLogs(lines);
    lines = [];
  }
  ctx.postMessage({
    type: 'progress',
    lines: lineCount,
    bytes: buf.length,
    totalBytes: buf.length
  });

  // Unset the buffer to free memory before passing message back to main window
  buf = undefined;
  localLogHandler.endFight();
  ctx.postMessage({
    type: 'done'
  });
});
/******/ })()
;